-----------
adapters\__init__.py

-----------

-----------
adapters\alpaca_adapter.py
# adapters/alpaca_adapter.py
import os
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

import alpaca_trade_api as tradeapi


class AlpacaAdapter:
    """
    Thin adapter around Alpaca REST API, configured purely by env vars:
    APCA_API_BASE_URL
    APCA_API_KEY_ID
    APCA_API_SECRET_KEY
    """

    def __init__(self, env_mode: str):
        self.env_mode = env_mode
        base_url = os.getenv("APCA_API_BASE_URL", "https://paper-api.alpaca.markets")
        key_id = os.getenv("APCA_API_KEY_ID")
        secret_key = os.getenv("APCA_API_SECRET_KEY")
        if not key_id or not secret_key:
            raise ValueError("APCA_API_KEY_ID and APCA_API_SECRET_KEY must be set")

        self.rest = tradeapi.REST(
            key_id=key_id,
            secret_key=secret_key,
            base_url=base_url,
            api_version="v2",
        )

    # --- Account / positions ---

    def get_account(self) -> Any:
        return self.rest.get_account()

    def list_positions(self) -> List[Any]:
        return list(self.rest.list_positions() or [])

    def get_position(self, symbol: str) -> Optional[Any]:
        try:
            return self.rest.get_position(symbol)
        except Exception:
            return None

    # --- Market status ---

    def get_market_open(self) -> bool:
        """
        Returns True if the US equity market is currently open, False otherwise.
        Uses Alpaca's /v2/clock endpoint.
        """
        try:
            clock = self.rest.get_clock()
            return bool(clock.is_open)
        except Exception:
            return False

    # --- Market data ---

    def get_last_quote(self, symbol: str) -> float:
        """
        Get a close/last price proxy via recent bars, fallback to latest trade.
        """
        end = datetime.utcnow()
        start = end - timedelta(minutes=60)

        try:
            bars = self.rest.get_bars(
                symbol,
                "5Min",
                start.isoformat() + "Z",
                end.isoformat() + "Z",
            )
        except Exception as e:
            print(f"get_bars error for {symbol}: {e}")
            bars = []

        if not bars:
            last = self.rest.get_latest_trade(symbol)
            return float(last.price)

        bar = bars[-1]
        close_price = getattr(bar, "c", None)
        if close_price is None:
            close_price = bar.c

        return float(close_price)

    def get_recent_bars(
        self,
        symbol: str,
        timeframe: str = "5Min",
        lookback_bars: int = 30,
    ) -> List[Any]:
        end = datetime.utcnow()
        start = end - timedelta(minutes=lookback_bars * 5 + 30)
        try:
            bars = self.rest.get_bars(
                symbol,
                timeframe,
                start.isoformat() + "Z",
                end.isoformat() + "Z",
                limit=lookback_bars,
            )
        except Exception as e:
            print(f"get_recent_bars error for {symbol}: {e}")
            bars = []
        return list(bars or [])

    # --- News / sentiment inputs ---

    def get_news(
        self,
        symbol: str,
        since: Optional[datetime] = None,
        limit: int = 20,
    ) -> List[Dict[str, str]]:
        try:
            kwargs: Dict[str, Any] = {"symbol": symbol, "limit": limit}
            if since is not None:
                kwargs["start"] = since.isoformat() + "Z"
            raw_items = self.rest.get_news(**kwargs)
        except Exception as e:
            print(f"get_news error for {symbol}: {e}")
            return []

        out: List[Dict[str, str]] = []
        for n in raw_items:
            headline = getattr(n, "headline", "") or ""
            summary = getattr(n, "summary", "") or ""
            out.append({"headline": headline, "summary": summary})
        return out

    # --- Orders ---

    def submit_market_order(
        self,
        symbol: str,
        qty: float,
        side: str,
        time_in_force: str = "day",
    ) -> Any:
        return self.rest.submit_order(
            symbol=symbol,
            side=side,
            type="market",
            qty=qty,
            time_in_force=time_in_force,
        )

    def submit_take_profit_limit_order(
        self,
        symbol: str,
        qty: float,
        side: str,
        limit_price: float,
        time_in_force: str = "day",
    ) -> Any:
        return self.rest.submit_order(
            symbol=symbol,
            side=side,
            type="limit",
            qty=qty,
            limit_price=limit_price,
            time_in_force=time_in_force,
        )

    def submit_trailing_stop_order(
        self,
        symbol: str,
        qty: float,
        side: str,
        trail_percent: float,
        time_in_force: str = "day",
    ) -> Any:
        return self.rest.submit_order(
            symbol=symbol,
            side=side,
            type="trailing_stop",
            qty=qty,
            trail_percent=trail_percent,
            time_in_force=time_in_force,
        )

    def cancel_order(self, order_id: str) -> None:
        self.rest.cancel_order(order_id)

    def cancel_all_orders(self) -> None:
        self.rest.cancel_all_orders()

    def close_all_positions(self) -> None:
        self.rest.close_all_positions()

    def list_orders(self, status: str = "open") -> List[Any]:
        return list(self.rest.list_orders(status=status) or [])



-----------

-----------
ai_client.py
# aiclient.py
import json
import os
import requests


class NewsReasoner:
    """
    Uses Perplexity's Chat Completions API (OpenAI-compatible with the sonar model)
    to score short-term news sentiment.

    Returns a dict with keys:
        - sentiment: int in {-2, -1, 0, 1}
        - confidence: float in [0, 1]
        - explanation: str
    """

    def __init__(self) -> None:
        # Read directly from environment variables
        self.apiurl = os.getenv("AI_API_URL", "https://api.perplexity.ai/chat/completions")
        self.apikey = os.getenv("AI_API_KEY")
        if not self.apikey:
            raise RuntimeError("AI_API_KEY is not set. Please export your Perplexity API key.")

    def scorenews(self, symbol: str, newsitems):
        """
        Input:
            symbol: string ticker, e.g. "AAPL"
            newsitems: list of dicts from Alpaca news API

        Output dict:
            - sentiment: -2, -1, 0, or 1
            - confidence: float 0-1
            - explanation: str
        """
        try:
            # No news -> neutral, low confidence
            if not newsitems:
                return {
                    "sentiment": 0,
                    "confidence": 0.0,
                    "explanation": "No recent news."
                }

            # Build compact headlines + summaries for up to 10 news items
            summaries = []
            for n in newsitems[:10]:
                title = n.get("headline") or n.get("title") or ""
                summary = n.get("summary") or ""
                text = f"{title} {summary}".strip()
                if not text:
                    continue
                summaries.append(text[:300])
            if not summaries:
                return {
                    "sentiment": 0,
                    "confidence": 0.0,
                    "explanation": "No usable news text."
                }

            userprompt = (
                f"You are a professional equity analyst.\n"
                f"Evaluate the SHORT-TERM (next few trading days) impact of the following news "
                f"on {symbol} stock.\n"
                f"Return a single JSON object with keys:\n"
                f'  sentiment: -2, -1, 0, or 1\n'
                f'    -2 for extremely unstable / utterly undesirable to trade now (e.g. chaotic, '
                f'        very high uncertainty, extreme event risk),\n'
                f'    -1 for clearly negative,\n'
                f'     0 for neutral or mixed,\n'
                f'     1 for clearly positive.\n'
                f'  confidence: a number between 0 and 1\n'
                f'  explanation: short textual explanation (1-3 sentences).\n\n'
                f"News:\n- " + "\n- ".join(summaries)
            )

            headers = {
                "Authorization": f"Bearer {self.apikey}",
                "Content-Type": "application/json",
            }
            payload = {
                "model": "sonar",
                "messages": [
                    {
                        "role": "system",
                        "content": (
                            "You are a precise financial sentiment classifier. "
                            "You only output strict JSON with the requested keys."
                        ),
                    },
                    {
                        "role": "user",
                        "content": userprompt,
                    },
                ],
                "temperature": 0.1,
                "max_tokens": 300,
            }

            resp = requests.post(self.apiurl, headers=headers, json=payload, timeout=30)
            if not resp.ok:
                # Log error and degrade gracefully to neutral sentiment
                print("Perplexity error", resp.status_code, resp.text)
                return {
                    "sentiment": 0,
                    "confidence": 0.0,
                    "explanation": "Error from AI API, treating sentiment as neutral.",
                }

            data = resp.json()
            rawcontent = data["choices"][0]["message"]["content"].strip()

            # Expect JSON, fallback to extracting JSON substring if needed
            try:
                result = json.loads(rawcontent)
            except json.JSONDecodeError:
                try:
                    start = rawcontent.index("{")
                    end = rawcontent.rindex("}") + 1
                    result = json.loads(rawcontent[start:end])
                except Exception:
                    return {
                        "sentiment": 0,
                        "confidence": 0.0,
                        "explanation": "Could not parse model output, treating as neutral.",
                    }

            sentiment = result.get("sentiment", 0)
            # Normalize sentiment to allowed set {-2, -1, 0, 1}
            if sentiment not in (-2, -1, 0, 1):
                sentiment = 0

            try:
                confidence = float(result.get("confidence", 0.0))
            except (TypeError, ValueError):
                confidence = 0.0
            confidence = max(0.0, min(1.0, confidence))

            explanation = result.get("explanation", "")

            return {
                "sentiment": sentiment,
                "confidence": confidence,
                "explanation": explanation,
            }

        except Exception as e:
            # Normalize fields on any unexpected error
            print("scorenews error", e)
            return {
                "sentiment": 0,
                "confidence": 0.0,
                "explanation": "Exception in sentiment analysis, treating as neutral.",
            }


-----------

-----------
config\__init__.py

-----------

-----------
config\config.py
# CHANGES:
#   - SentimentConfig: added exit_sentiment_delta_threshold (default 0.7) and
#     exit_confidence_min (default 0.5).
#     These gate the sentiment-driven forced-exit logic in main.py.
#     Both are additive fields with defaults; no existing field touched.

import os
import yaml
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import Dict


ENV_MODE = os.getenv("APCA_API_ENV", "PAPER").upper()
if ENV_MODE not in ("PAPER", "LIVE"):
    raise ValueError(f"Invalid APCA_API_ENV={ENV_MODE}, expected PAPER or LIVE")

LIVE_TRADING_ENABLED = os.getenv("LIVE_TRADING_ENABLED", "false").lower() == "true"


@dataclass
class RiskLimits:
    max_risk_per_trade_pct: float = 0.03     # 3% of equity (was 1%)
    min_risk_per_trade_pct: float = 0.005    # 0.5% of equity
    gross_exposure_cap_pct: float = 0.90     # 90% of equity
    daily_loss_limit_pct: float = 0.04       # 4% of start-of-day equity
    max_drawdown_pct: float = 0.09           # 9% from high watermark
    max_open_positions: int = 15


@dataclass
class SentimentConfig:
    neutral_band: float = 0.1
    min_scale: float = 0.2
    max_scale: float = 1.3
    no_trade_negative_threshold: float = -0.4
    # --- Sentiment-exit thresholds (Feature 1) ---
    # Minimum absolute shift in sentiment compound score required to trigger a forced exit.
    # A position opened when compound was +0.8 and now scoring +0.05 yields delta = 0.75 → exit.
    exit_sentiment_delta_threshold: float = 0.7
    # Minimum model confidence in the *current* (adverse) sentiment reading before we act on it.
    # Prevents low-confidence noise from closing profitable positions.
    exit_confidence_min: float = 0.5


@dataclass
class TechnicalSignalConfig:
    weight_momentum_trend: float = 0.5
    weight_mean_reversion: float = 0.3
    weight_price_action: float = 0.2
    long_threshold: float = 0.2
    short_threshold: float = -0.2
    momentum_norm_scale: float = 0.05
    ma_distance_norm_scale: float = 0.05
    rsi_overbought: float = 70.0
    rsi_oversold: float = 30.0
    breakout_lookback_bars: int = 20
    breakout_strength: float = 1.0
    base_stop_vol_mult: float = 1.5
    base_tp_vol_mult: float = 3.0
    max_tp_scale_from_signal: float = 1.3
    min_tp_scale_from_signal: float = 0.7


@dataclass
class ExecutionConfig:
    enable_trailing_stop: bool = True
    trailing_stop_percent: float = 5.0   # 5% trailing distance
    enable_take_profit: bool = True
    exit_time_in_force: str = "day"
    entry_time_in_force: str = "day"
    post_entry_fill_timeout_sec: int = 15


@dataclass
class InstrumentMeta:
    symbol: str
    exchange: str
    lot_size: float
    fractional: bool
    shortable: bool
    marginable: bool
    trading_hours: str
    sector: str = "UNKNOWN"


@dataclass
class PortfolioConfig:
    enable_portfolio_veto: bool = False
    max_candidates_per_loop: int = 50


@dataclass
class BotConfig:
    env_mode: str
    live_trading_enabled: bool
    risk_limits: RiskLimits
    sentiment: SentimentConfig
    technical: TechnicalSignalConfig
    execution: ExecutionConfig
    instruments: Dict[str, InstrumentMeta]
    portfolio: PortfolioConfig


@dataclass
class AIConfig:
    api_url: str
    api_key: str


def _load_instrument_whitelist(path: Path) -> Dict[str, InstrumentMeta]:
    if not path.exists():
        raise FileNotFoundError(f"Instrument whitelist not found at {path}")
    with path.open("r") as f:
        data = yaml.safe_load(f) or {}
    instruments: Dict[str, InstrumentMeta] = {}
    for sym, meta in data.items():
        instruments[sym] = InstrumentMeta(
            symbol=sym,
            exchange=meta.get("exchange", "NYSE"),
            lot_size=float(meta.get("lot_size", 1)),
            fractional=bool(meta.get("fractional", False)),
            shortable=bool(meta.get("shortable", False)),
            marginable=bool(meta.get("marginable", False)),
            trading_hours=meta.get("trading_hours", "09:30-16:00"),
            sector=meta.get("sector", "UNKNOWN"),
        )
    return instruments


def load_config() -> BotConfig:
    base = Path(__file__).resolve().parents[1]
    wl_path = base / "config" / "instrument_whitelist.yaml"
    instruments = _load_instrument_whitelist(wl_path)

    risk = RiskLimits()
    sentiment = SentimentConfig()
    technical = TechnicalSignalConfig()
    execution = ExecutionConfig()
    portfolio = PortfolioConfig()

    cfg = BotConfig(
        env_mode=ENV_MODE,
        live_trading_enabled=LIVE_TRADING_ENABLED,
        risk_limits=risk,
        sentiment=sentiment,
        technical=technical,
        execution=execution,
        instruments=instruments,
        portfolio=portfolio,
    )
    return cfg


if __name__ == "__main__":
    cfg = load_config()
    print(asdict(cfg))



-----------

-----------
config\instrument_whitelist.yaml
AAPL:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

MSFT:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

GOOGL:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

AMZN:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

NVDA:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

META:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

TSLA:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

AMD:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

MU:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

NFLX:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

SPY:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

QQQ:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

VOO:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

IWM:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

XLF:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

XLE:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

SLV:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

EEM:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

BAC:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

COST:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "09:30-16:00"

SPY:
  exchange: ARCA
  lotsize: 1
  fractional: true
  shortable: true
  marginable: true
  tradinghours: "0930-1600"
  sector: INDEX   # S&P 500 proxy

FXE:
  exchange: ARCA
  lotsize: 1
  fractional: true
  shortable: true
  marginable: true
  tradinghours: "0930-1600"
  sector: FX      # EUR vs USD proxy

-----------

-----------
core\__init__.py

-----------

-----------
core\portfolio_builder.py
# core/portfolio_builder.py

from typing import Dict, List, Any

from adapters.alpaca_adapter import AlpacaAdapter
from core.signals import SignalEngine, Signal
from core.sentiment import SentimentModule
from core.risk_engine import RiskEngine, EquitySnapshot, PositionInfo, ProposedTrade
from config.config import BotConfig
from .portfolio_veto import PortfolioVeto


class PortfolioBuilder:
    """
    Portfolio-level builder:
    - Compute signal_score and side for each instrument.
    - Run pre_trade_checks -> ProposedTrade.
    - Rank by |signal_score| and select until portfolio limits are hit.
    - Optional Sonar veto.
    """

    def __init__(
        self,
        cfg: BotConfig,
        adapter: AlpacaAdapter,
        sentiment: SentimentModule,
        signal_engine: SignalEngine,
        risk_engine: RiskEngine,
    ) -> None:
        self.cfg = cfg
        self.adapter = adapter
        self.sentiment = sentiment
        self.signal_engine = signal_engine
        self.risk_engine = risk_engine
        self.veto = PortfolioVeto()

    def _build_candidate_for_symbol(
        self,
        symbol: str,
        snapshot: EquitySnapshot,
        positions: Dict[str, PositionInfo],
        pending_symbols: set,
    ) -> ProposedTrade:
        
        # --- DUPLICATE-ORDER & NO EQUITY GUARD ---
        # If we already hold a position in this symbol, skip immediately (no AI API calls).
        if symbol in positions:
            return ProposedTrade(
                symbol=symbol,
                side="buy",
                qty=0.0,
                entry_price=0.0,
                stop_price=0.0,
                take_profit_price=0.0,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=0.0,
                sentiment_scale=0.0,
                signal_score=0.0,
                rationale="Position already open for this symbol",
                rejected_reason="Position already open; skipping to prevent duplicate order and save API calls",
            )
            
        # If an order is already pending, skip immediately (no AI API calls).
        if symbol in pending_symbols:
            return ProposedTrade(
                symbol=symbol,
                side="buy",
                qty=0.0,
                entry_price=0.0,
                stop_price=0.0,
                take_profit_price=0.0,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=0.0,
                sentiment_scale=0.0,
                signal_score=0.0,
                rationale="Pending order exists for this symbol",
                rejected_reason="Pending order exists; skipping to prevent duplicate order and save API calls",
            )

        # Signal Engine is queried AFTER validation, saving an AI API call if conditions are unmet.
        sig: Signal = self.signal_engine.generate_signal_for_symbol(symbol)

        if sig.side == "skip":
            return ProposedTrade(
                symbol=sig.symbol,
                side="buy",
                qty=0.0,
                entry_price=0.0,
                stop_price=0.0,
                take_profit_price=0.0,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sig.sentiment_result.score,
                sentiment_scale=0.0,
                signal_score=sig.signal_score,
                rationale=sig.rationale,
                rejected_reason="Signal neutral/skip",
            )

        entry_price = self.adapter.get_last_quote(symbol)

        proposed = self.risk_engine.pre_trade_checks(
            snapshot=snapshot,
            positions=positions,
            symbol=sig.symbol,
            side=sig.side,
            entry_price=entry_price,
            stop_price=sig.stop_price,
            take_profit_price=sig.take_profit_price,
            sentiment=sig.sentiment_result,
            signal_score=sig.signal_score,
            rationale=sig.rationale,
        )
        return proposed

    def build_portfolio(
        self,
        snapshot: EquitySnapshot,
        positions: Dict[str, PositionInfo],
        open_orders: List[Any],
    ) -> List[ProposedTrade]:
        
        # Defense-in-depth: if fully allocated globally, skip all portfolio generation.
        exposure_cap_notional = snapshot.equity * self.cfg.risk_limits.gross_exposure_cap_pct
        if snapshot.gross_exposure >= exposure_cap_notional or len(positions) >= self.cfg.risk_limits.max_open_positions:
            return []

        pending_symbols = {getattr(o, "symbol", "") for o in open_orders if hasattr(o, "symbol")}

        symbols = list(self.cfg.instruments.keys())
        max_candidates = self.cfg.portfolio.max_candidates_per_loop
        if max_candidates > 0:
            symbols = symbols[:max_candidates]

        candidates: List[ProposedTrade] = []
        for sym in symbols:
            candidate = self._build_candidate_for_symbol(sym, snapshot, positions, pending_symbols)
            candidates.append(candidate)

        feasible: List[ProposedTrade] = [
            t for t in candidates if t.qty > 0 and t.rejected_reason is None
        ]
        if not feasible:
            return []

        feasible.sort(key=lambda t: abs(t.signal_score), reverse=True)

        selected: List[ProposedTrade] = []
        current_gross = snapshot.gross_exposure
        current_open_positions = len(positions)

        for t in feasible:
            # Secondary guard (defensive): never select a symbol already in positions.
            if t.symbol in positions:
                continue

            notional = t.qty * t.entry_price
            projected_gross = current_gross + abs(notional)

            if projected_gross > snapshot.equity * self.cfg.risk_limits.gross_exposure_cap_pct:
                continue

            new_symbol = t.symbol not in positions
            projected_positions = current_open_positions + (1 if new_symbol else 0)
            if projected_positions > self.cfg.risk_limits.max_open_positions:
                continue

            selected.append(t)
            current_gross = projected_gross
            if new_symbol:
                current_open_positions = projected_positions

        if not selected:
            return []

        if self.cfg.portfolio.enable_portfolio_veto:
            selected = self.veto.apply_veto(selected)

        return selected


-----------

-----------
core\portfolio_veto.py
# core/portfolio_veto.py
import json
import os
from typing import Dict, List

import requests

from core.risk_engine import ProposedTrade


class PortfolioVeto:
    """
    Optional portfolio-level veto layer using Perplexity Sonar.

    Given a list of ProposedTrade candidates (already risk-checked),
    prepares a compact prompt and expects a JSON mapping symbol -> 0/1,
    where 0 means veto (do not trade), 1 means allow.

    Controlled by config.portfolio.enable_portfolio_veto.
    """

    def __init__(self) -> None:
        self.apiurl = os.getenv("AI_API_URL", "https://api.perplexity.ai/chat/completions")
        self.apikey = os.getenv("AI_API_KEY")
        if not self.apikey:
            # Fail soft: without API key, veto layer is effectively a no-op
            self.disabled = True
        else:
            self.disabled = False

    def _build_prompt(self, trades: List[ProposedTrade]) -> str:
        lines = []
        for t in trades:
            notional = t.qty * t.entry_price
            line = {
                "symbol": t.symbol,
                "side": t.side,
                "notional": round(notional, 2),
                "signal_score": round(t.signal_score, 3),
                "sentiment_score": round(t.sentiment_score, 3),
                "reason": (t.rationale or "")[:200],
            }
            lines.append(line)

        return (
            "You are a risk-aware portfolio reviewer.\n"
            "You will receive a list of proposed short-term trades for US equities.\n"
            "Each trade includes symbol, side, notional size, a technical signal_score in [-1,1],\n"
            "and a sentiment_score in [-1,1].\n\n"
            "Your task: return a single JSON object mapping each symbol to 0 or 1.\n"
            "1 = trade is acceptable, 0 = veto due to extreme risk, obvious conflict, or\n"
            "major concern (e.g. very unstable situation, illogical rationale).\n"
            "Be conservative but do NOT overfit; use 0 only for clearly problematic trades.\n\n"
            "Input trades:\n"
            + json.dumps(lines, indent=2)
        )

    def apply_veto(self, trades: List[ProposedTrade]) -> List[ProposedTrade]:
        if self.disabled or not trades:
            return trades

        prompt = self._build_prompt(trades)
        headers = {
            "Authorization": f"Bearer {self.apikey}",
            "Content-Type": "application/json",
        }
        payload = {
            "model": "sonar",
            "messages": [
                {
                    "role": "system",
                    "content": (
                        "You are a precise portfolio veto engine. "
                        "You only output strict JSON with {symbol: 0 or 1} entries."
                    ),
                },
                {
                    "role": "user",
                    "content": prompt,
                },
            ],
            "temperature": 0.1,
            "max_tokens": 400,
        }

        try:
            resp = requests.post(self.apiurl, headers=headers, json=payload, timeout=30)
            if not resp.ok:
                print("PortfolioVeto API error", resp.status_code, resp.text)
                return trades

            data = resp.json()
            rawcontent = data["choices"][0]["message"]["content"].strip()
            try:
                result = json.loads(rawcontent)
            except json.JSONDecodeError:
                start = rawcontent.find("{")
                end = rawcontent.rfind("}")
                if start == -1 or end == -1:
                    return trades
                result = json.loads(rawcontent[start : end + 1])

            allowed: List[ProposedTrade] = []
            for t in trades:
                flag = result.get(t.symbol, 1)
                try:
                    flag_int = int(flag)
                except (TypeError, ValueError):
                    flag_int = 1
                if flag_int == 1:
                    allowed.append(t)
            return allowed
        except Exception as e:
            print("PortfolioVeto exception", e)
            return trades

-----------

-----------
core\risk_engine.py
# core/risk_engine.py

from dataclasses import dataclass
from typing import Optional, Dict

from .sentiment import SentimentResult
from config.config import RiskLimits, SentimentConfig, InstrumentMeta


@dataclass
class EquitySnapshot:
    equity: float
    cash: float
    portfolio_value: float
    day_trading_buying_power: float
    start_of_day_equity: float
    high_watermark_equity: float
    realized_pl_today: float
    unrealized_pl: float
    gross_exposure: float  # sum |position_notional|
    daily_loss_pct: float
    drawdown_pct: float


@dataclass
class PositionInfo:
    symbol: str
    qty: float
    market_price: float
    side: str  # long/short
    notional: float


@dataclass
class ProposedTrade:
    symbol: str
    side: str
    qty: float
    entry_price: float
    stop_price: float
    take_profit_price: float
    risk_amount: float
    risk_pct_of_equity: float
    sentiment_score: float
    sentiment_scale: float
    signal_score: float = 0.0
    rationale: Optional[str] = None
    rejected_reason: Optional[str] = None


class RiskEngine:
    def __init__(
        self,
        risk_limits: RiskLimits,
        sentiment_cfg: SentimentConfig,
        instrument_meta: Dict[str, InstrumentMeta],
    ) -> None:
        self.limits = risk_limits
        self.sentiment_cfg = sentiment_cfg
        self.instrument_meta = instrument_meta

    def sentiment_scale(self, s: float) -> float:
        if s < self.sentiment_cfg.no_trade_negative_threshold:
            return 0.0
        if abs(s) <= self.sentiment_cfg.neutral_band:
            return 1.0
        span = self.sentiment_cfg.max_scale - self.sentiment_cfg.min_scale
        scaled = self.sentiment_cfg.min_scale + (s + 1) / 2 * span
        return max(self.sentiment_cfg.min_scale, min(self.sentiment_cfg.max_scale, scaled))

    def pre_trade_checks(
        self,
        snapshot: EquitySnapshot,
        positions: Dict[str, PositionInfo],
        symbol: str,
        side: str,
        entry_price: float,
        stop_price: float,
        take_profit_price: float,
        sentiment: SentimentResult,
        signal_score: float = 0.0,
        rationale: Optional[str] = None,
    ) -> ProposedTrade:
        # 0) Instrument whitelist
        if symbol not in self.instrument_meta:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=0.0,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Instrument not whitelisted",
            )

        # 1) hard block for unstable / utterly undesirable sentiment (-2)
        if getattr(sentiment, "raw_discrete", 0) == -2:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=0.0,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Sentiment -2 (unstable / do not trade)",
            )

        meta = self.instrument_meta[symbol]

        # 2) Sentiment-based sizing scale
        s_scale = self.sentiment_scale(sentiment.score)
        if s_scale == 0.0:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=0.0,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Sentiment too negative for new trade",
            )

        # 3) Validate stop distance
        stop_distance = abs(entry_price - stop_price)
        if stop_distance <= 0:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Invalid stop distance",
            )

        # 4) Risk per trade, scaled by sentiment (but capped by min/max)
        base_risk_pct = self.limits.max_risk_per_trade_pct
        risk_pct = min(
            self.limits.max_risk_per_trade_pct,
            max(self.limits.min_risk_per_trade_pct, base_risk_pct * s_scale),
        )
        risk_amount = snapshot.equity * risk_pct

        # 5) Size by risk and force whole-lot qty
        qty = risk_amount / stop_distance
        qty = int(qty / meta.lot_size) * meta.lot_size

        if qty <= 0:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Calculated quantity is zero",
            )

        # 6) Broker-aware cap: fraction of equity per trade
        max_notional_broker = 0.4 * snapshot.equity
        projected_notional = qty * entry_price
        if projected_notional > max_notional_broker:
            max_qty_broker = int(max_notional_broker / entry_price / meta.lot_size) * meta.lot_size
            if max_qty_broker <= 0:
                return ProposedTrade(
                    symbol=symbol,
                    side=side,
                    qty=0.0,
                    entry_price=entry_price,
                    stop_price=stop_price,
                    take_profit_price=take_profit_price,
                    risk_amount=risk_amount,
                    risk_pct_of_equity=risk_pct,
                    sentiment_score=sentiment.score,
                    sentiment_scale=s_scale,
                    signal_score=signal_score,
                    rationale=rationale,
                    rejected_reason="Broker buying power cap per trade",
                )
            qty = max_qty_broker
            projected_notional = qty * entry_price

        # 7) Gross exposure / loss / drawdown / position-count rules

        projected_gross = snapshot.gross_exposure + abs(projected_notional)
        if projected_gross > snapshot.equity * self.limits.gross_exposure_cap_pct:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=risk_amount,
                risk_pct_of_equity=risk_pct,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Gross exposure cap breached",
            )

        if snapshot.daily_loss_pct <= -self.limits.daily_loss_limit_pct:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=risk_amount,
                risk_pct_of_equity=risk_pct,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Daily loss limit breached",
            )

        if snapshot.drawdown_pct <= -self.limits.max_drawdown_pct:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=risk_amount,
                risk_pct_of_equity=risk_pct,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Max drawdown limit breached",
            )

        if len(positions) >= self.limits.max_open_positions and symbol not in positions:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=risk_amount,
                risk_pct_of_equity=risk_pct,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Max open positions exceeded",
            )

        return ProposedTrade(
            symbol=symbol,
            side=side,
            qty=qty,
            entry_price=entry_price,
            stop_price=stop_price,
            take_profit_price=take_profit_price,
            risk_amount=risk_amount,
            risk_pct_of_equity=risk_pct,
            sentiment_score=sentiment.score,
            sentiment_scale=s_scale,
            signal_score=signal_score,
            rationale=rationale,
            rejected_reason=None,
        )







-----------

-----------
core\sentiment.py
# CHANGES:
#   - Added force_rescore(symbol, newsitems) method.
#     This bypasses the TTL cache and chaos cooldown to always call the AI for
#     open-position sentiment-exit checks. It still writes the result back to the
#     cache so subsequent normal scoring benefits from it.
#     The existing scorenewsitems(), get_cached_sentiment(), _neutral(),
#     _map_discrete_to_score(), _get_last_known(), _set_last_known() methods are
#     completely untouched. No field renames.

from __future__ import annotations

import os
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

from ai_client import NewsReasoner


@dataclass
class SentimentResult:
    """
    score: continuous sentiment score in [-1, 1] for risk sizing.
           -1 strongly negative, +1 strongly positive.
           For discrete -2 (utterly undesirable / unstable), score is fixed at -1
           and should trigger no-trade / forced exit logic at the risk engine level.
    raw_discrete: the raw discrete value from the model in {-2, -1, 0, 1}
    rawcompound: legacy field; kept for compatibility, here = score
    ndocuments: number of news items used
    explanation: optional short explanation
    confidence: model-reported confidence in [0, 1]
    """
    score: float
    raw_discrete: int
    rawcompound: float
    ndocuments: int
    explanation: Optional[str] = None
    confidence: float = 0.0


class SentimentModule:
    """
    Sentiment engine backed by Perplexity Sonar via NewsReasoner.

    Implements cost controls:
      (1) TTL-based per-symbol cache to reduce AI calls.
      (2) If no *new* news arrives for a symbol, reuse last-known sentiment (no AI call).
      (6) If last-known raw_discrete == -2, apply a cooldown window during which we do not
          call the AI again for that symbol (even if new news arrives).
    """

    def __init__(self) -> None:
        self.reasoner = NewsReasoner()

        ttl_min = int(os.getenv("SENTIMENT_CACHE_TTL_MIN", "30"))
        ttl_min = max(1, ttl_min)
        self.cache_ttl = timedelta(minutes=ttl_min)

        chaos_cd_min = int(os.getenv("SENTIMENT_CHAOS_COOLDOWN_MIN", "120"))
        chaos_cd_min = max(0, chaos_cd_min)
        self.chaos_cooldown = timedelta(minutes=chaos_cd_min)

        # Cache is the single source of truth for last-known sentiment.
        # symbol -> (SentimentResult, timestamp_utc)
        self._cache: Dict[str, Tuple[SentimentResult, datetime]] = {}

    def _neutral(self, reason: str, ndocs: int = 0) -> SentimentResult:
        return SentimentResult(
            score=0.0,
            raw_discrete=0,
            rawcompound=0.0,
            ndocuments=ndocs,
            explanation=reason,
            confidence=0.0,
        )

    def _map_discrete_to_score(self, sdisc: int, confidence: float) -> float:
        """
        Map discrete sentiment {-2, -1, 0, 1} plus confidence into a continuous score in [-1, 1].
        """
        confidence = max(0.0, min(1.0, confidence))

        if sdisc == -2:
            # Hard floor at -1 to signal "utterly undesirable / unstable".
            return -1.0

        if sdisc == -1:
            base = -1.0
        elif sdisc == 0:
            base = 0.0
        elif sdisc == 1:
            base = 1.0
        else:
            base = 0.0

        return max(-1.0, min(1.0, base * confidence))

    def get_cached_sentiment(self, symbol: str) -> Optional[SentimentResult]:
        """
        TTL cache getter.
        Returns a cached sentiment only if it is within the TTL window.
        """
        now = datetime.utcnow()
        cached = self._cache.get(symbol)
        if not cached:
            return None
        result, ts = cached
        if now - ts <= self.cache_ttl:
            return result
        return None

    def _get_last_known(self, symbol: str) -> Optional[Tuple[SentimentResult, datetime]]:
        return self._cache.get(symbol)

    def _set_last_known(self, symbol: str, result: SentimentResult) -> None:
        self._cache[symbol] = (result, datetime.utcnow())

    def _call_ai(self, symbol: str, newsitems: List[dict]) -> SentimentResult:
        """
        Internal: call the AI, parse the result, update the cache, and return a
        SentimentResult. Used by both scorenewsitems() and force_rescore().
        """
        res = self.reasoner.scorenews(symbol, newsitems)

        try:
            sdisc = int(res.get("sentiment", 0))
        except (TypeError, ValueError):
            sdisc = 0
        if sdisc not in (-2, -1, 0, 1):
            sdisc = 0

        try:
            confidence = float(res.get("confidence", 0.0))
        except (TypeError, ValueError):
            confidence = 0.0
        confidence = max(0.0, min(1.0, confidence))

        explanation = res.get("explanation", "") or ""
        score = self._map_discrete_to_score(sdisc, confidence)

        result = SentimentResult(
            score=score,
            raw_discrete=sdisc,
            rawcompound=score,
            ndocuments=len(newsitems),
            explanation=explanation,
            confidence=confidence,
        )
        self._set_last_known(symbol, result)
        return result

    def scorenewsitems(self, symbol: str, newsitems: List[dict]) -> SentimentResult:
        """
        newsitems: list of dicts (typically *new since last check* from Alpaca news API),
                  each with at least 'headline' and/or 'summary'.

        Cost controls:
          - If there are no new news items and we have a last-known sentiment, reuse it. (2)
          - If cached sentiment is still fresh (TTL), reuse it. (1)
          - If last-known sentiment is -2 and still within cooldown, reuse it. (6)
        """
        now = datetime.utcnow()
        last_known = self._get_last_known(symbol)

        # (6) Chaos cooldown: if we recently deemed the symbol "unstable / -2", don't rescore.
        if last_known:
            last_res, last_ts = last_known
            if last_res.raw_discrete == -2 and (now - last_ts) <= self.chaos_cooldown:
                return last_res

        # (2) No new news -> do not call AI; just reuse last-known sentiment if available.
        if not newsitems:
            if last_known:
                return last_known[0]
            return self._neutral("No recent news (no prior sentiment cached).", ndocs=0)

        # (1) TTL cache: if within TTL, reuse cached sentiment even if new news exists.
        # Rationale: avoids frequent rescores when headlines trickle in; TTL bounds staleness.
        cached_fresh = self.get_cached_sentiment(symbol)
        if cached_fresh is not None:
            return cached_fresh

        return self._call_ai(symbol, newsitems)

    def force_rescore(self, symbol: str, newsitems: List[dict]) -> SentimentResult:
        """
        Unconditional AI rescore — bypasses TTL cache and chaos cooldown.

        Use this exclusively for open-position sentiment-exit checks, where stale
        cached data would cause the exit logic to silently produce delta = 0 and
        never fire.

        If newsitems is empty the AI cannot reason about new information; in that
        case we fall back to the last-known cached result (if any) or neutral.
        We do NOT want to exit a position solely because news is thin — the caller
        must decide what to do with a low-confidence neutral result.
        """
        if not newsitems:
            last_known = self._get_last_known(symbol)
            if last_known:
                return last_known[0]
            return self._neutral("No recent news for forced rescore.", ndocs=0)

        return self._call_ai(symbol, newsitems)

-----------

-----------
core\signals.py
# core/signals.py
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

import math

from adapters.alpaca_adapter import AlpacaAdapter
from config.config import ENV_MODE, TechnicalSignalConfig
from monitoring.monitor import log_sentiment_for_symbol, log_signal_score

from .sentiment import SentimentModule, SentimentResult


@dataclass
class Signal:
    symbol: str
    side: str  # "buy", "sell", or "skip"
    rationale: str
    sentiment_result: SentimentResult
    stop_price: float
    take_profit_price: float
    signal_score: float
    momentum_score: float
    mean_reversion_score: float
    price_action_score: float


class SignalEngine:
    """
    Composite technical signal engine:
      - Momentum/trend
      - Mean reversion (RSI / MA distance proxy)
      - Price action structure

    AI cost controls implemented here:
      (3) Compute technical signal first; if side == "skip", do not fetch news or call AI.
    Suggestion (2) is enforced in SentimentModule.scorenewsitems via reuse when no new news arrives.
    """

    def __init__(
        self,
        adapter: AlpacaAdapter,
        sentiment: SentimentModule,
        technicalcfg: TechnicalSignalConfig,
    ):
        self.adapter = adapter
        self.sentiment = sentiment
        self.technicalcfg = technicalcfg

    def _compute_simple_momentum_raw(self, bars: List) -> float:
        """
        Simple momentum: (Current Close - Close N bars ago) / Close N bars ago
        """
        if not bars or len(bars) < 10:
            return 0.0
        
        # fallback if not enough bars for full lookback, just use what we have
        lookback = min(len(bars) - 1, 10)
        current = bars[-1].c
        past = bars[-1 - lookback].c
        
        if past == 0:
            return 0.0
        return (current - past) / past

    def _compute_trend_signal_raw(self, bars: List) -> float:
        """
        Simple trend proxy: is price above SMA(20)?
        Returns +1 if > SMA, -1 if < SMA, 0 otherwise.
        """
        if len(bars) < 20:
            return 0.0
        
        closes = [b.c for b in bars]
        # last 20 bars
        window = closes[-20:]
        sma = sum(window) / len(window)
        current = closes[-1]
        
        if current > sma:
            return 1.0
        elif current < sma:
            return -1.0
        return 0.0

    def _compute_volatility(self, bars: List) -> float:
        """
        ATR-like proxy or simple std dev of last N closes.
        Let's use a percentage volatility proxy: Stdev(returns) * sqrt(bars)
        """
        if len(bars) < 5:
            return 0.01  # fallback
        
        closes = [b.c for b in bars]
        returns = []
        for i in range(1, len(closes)):
            r = (closes[i] - closes[i-1]) / closes[i-1]
            returns.append(r)
        
        if not returns:
            return 0.01
            
        mean_ret = sum(returns) / len(returns)
        sq_diffs = [(r - mean_ret)**2 for r in returns]
        variance = sum(sq_diffs) / len(returns)
        std_dev = math.sqrt(variance)
        
        # Annualized-ish or per-bar? Just use per-bar std dev as vol proxy
        return std_dev

    def _compute_rsi(self, bars: List, period: int = 14) -> float:
        if len(bars) < period + 1:
            return 50.0
        
        closes = [b.c for b in bars]
        deltas = [closes[i] - closes[i-1] for i in range(1, len(closes))]
        
        gains = [d for d in deltas if d > 0]
        losses = [-d for d in deltas if d < 0]
        
        avg_gain = sum(gains) / period if gains else 0.0
        avg_loss = sum(losses) / period if losses else 0.0
        
        if avg_loss == 0:
            return 100.0
        
        rs = avg_gain / avg_loss
        return 100.0 - (100.0 / (1.0 + rs))

    def _normalize_momentum_trend(self, mom_raw: float, trend_raw: float) -> float:
        # Scale momentum: if mom is 1%, that's huge in 5min bars. 
        # standardizing roughly: mom / 0.005 -> clamped
        mom_score = max(-1.0, min(1.0, mom_raw / self.technicalcfg.momentum_norm_scale))
        
        # Combine with trend (-1 or 1)
        # 70% momentum value, 30% trend direction
        combined = 0.7 * mom_score + 0.3 * trend_raw
        return combined

    def _normalize_mean_reversion(self, current_price: float, bars: List, rsi: float) -> float:
        """
        Mean reversion score:
        High RSI (>70) -> Negative score (expect pullback)
        Low RSI (<30) -> Positive score (expect bounce)
        
        Also distance from MA: if price >> MA, revert down (-).
        """
        # RSI component
        rsi_score = 0.0
        if rsi > self.technicalcfg.rsi_overbought:
            # e.g. 75 -> -0.5
            rsi_score = -1.0 * (rsi - 70) / 30.0
        elif rsi < self.technicalcfg.rsi_oversold:
            # e.g. 25 -> +0.5
            rsi_score = 1.0 * (30 - rsi) / 30.0
        
        # MA distance component
        if len(bars) < 20:
            ma_score = 0.0
        else:
            closes = [b.c for b in bars[-20:]]
            sma = sum(closes) / len(closes)
            # (price - sma) / sma
            dist = (current_price - sma) / sma
            # if dist is +1%, score is negative (revert)
            # scale: 0.05 (5%) -> full -1.0
            ma_score = -1.0 * (dist / self.technicalcfg.ma_distance_norm_scale)
            
        return max(-1.0, min(1.0, 0.5 * rsi_score + 0.5 * ma_score))

    def _compute_price_action_score(self, bars: List, current_price: float) -> float:
        """
        Simple breakout detection:
        If current price > highest of last N bars -> +1 (Breakout)
        If current price < lowest of last N bars -> -1 (Breakdown)
        """
        if len(bars) < self.technicalcfg.breakout_lookback_bars:
            return 0.0
            
        window = bars[-self.technicalcfg.breakout_lookback_bars:-1] # exclude current
        highs = [b.h for b in window]
        lows = [b.l for b in window]
        
        recent_high = max(highs)
        recent_low = min(lows)
        
        if current_price > recent_high:
            return 1.0
        elif current_price < recent_low:
            return -1.0
            
        return 0.0

    def _combine_technical_scores(self, mom: float, mr: float, pa: float) -> float:
        # weights from config
        score = (
            self.technicalcfg.weight_momentum_trend * mom +
            self.technicalcfg.weight_mean_reversion * mr +
            self.technicalcfg.weight_price_action * pa
        )
        return max(-1.0, min(1.0, score))

    def _decide_side_and_bands(self, last_price: float, volatility: float, signal_score: float) -> Tuple[str, float, float]:
        long_th = float(self.technicalcfg.long_threshold)
        short_th = float(self.technicalcfg.short_threshold)

        side = "skip"
        if signal_score >= long_th:
            side = "buy"
        elif signal_score <= short_th:
            side = "sell"

        # Use price-based volatility proxy for bands.
        # If volatility is tiny, fall back to a minimal band.
        vol_px = max(0.0025 * last_price, volatility * last_price)

        stop_mult = float(self.technicalcfg.base_stop_vol_mult)
        tp_mult = float(self.technicalcfg.base_tp_vol_mult)

        tp_scale = 1.0
        # Scale TP slightly with conviction but clamp.
        min_tp_scale = float(self.technicalcfg.min_tp_scale_from_signal)
        max_tp_scale = float(self.technicalcfg.max_tp_scale_from_signal)
        tp_scale = max(min_tp_scale, min(max_tp_scale, 1.0 + 0.3 * abs(signal_score)))

        if side == "buy":
            stop = last_price - stop_mult * vol_px
            tp = last_price + tp_mult * vol_px * tp_scale
        elif side == "sell":
            stop = last_price + stop_mult * vol_px
            tp = last_price - tp_mult * vol_px * tp_scale
        else:
            # Still return bands, but they won't be used.
            stop = last_price
            tp = last_price

        return side, float(stop), float(tp)

    def _get_news_items(self, symbol: str) -> List[Dict]:
        """
        Fetch news from Alpaca adapter.
        """
        # We only want news from last 24h or so?
        # Adapter handles the 'limit' and 'since' logic if needed.
        # Here we just ask for latest 10 items.
        return self.adapter.get_news(symbol, limit=10)

    def generate_signal_for_symbol(self, symbol: str) -> Signal:
        last_trade = self.adapter.get_last_quote(symbol)
        bars = self.adapter.get_recent_bars(symbol, timeframe="5Min", lookback_bars=30)

        momentum_raw = self._compute_simple_momentum_raw(bars)
        trend_raw = self._compute_trend_signal_raw(bars)
        volatility = self._compute_volatility(bars)
        rsi = self._compute_rsi(bars)

        momentum_score = self._normalize_momentum_trend(momentum_raw, trend_raw)
        mean_reversion_score = self._normalize_mean_reversion(last_trade, bars, rsi)
        price_action_score = self._compute_price_action_score(bars, last_trade)

        signal_score = self._combine_technical_scores(
            momentum_score, mean_reversion_score, price_action_score
        )

        side, stop_price, take_profit_price = self._decide_side_and_bands(
            last_price=last_trade,
            volatility=volatility,
            signal_score=signal_score,
        )

        if side == "skip":
            rationale = (
                f"Composite technical signal_score={signal_score:.3f} "
                f"within neutral band; no trade."
            )
        elif side == "buy":
            rationale = (
                f"Long bias from composite technicals: signal_score={signal_score:.3f}, "
                f"momentum={momentum_score:.3f}, mean_reversion={mean_reversion_score:.3f}, "
                f"price_action={price_action_score:.3f}."
            )
        else:
            rationale = (
                f"Short bias from composite technicals: signal_score={signal_score:.3f}, "
                f"momentum={momentum_score:.3f}, mean_reversion={mean_reversion_score:.3f}, "
                f"price_action={price_action_score:.3f}."
            )

        # Always log composite and factor scores, regardless of trade decision.
        log_signal_score(
            symbol=symbol,
            signal_score=signal_score,
            momentum_score=momentum_score,
            mean_reversion_score=mean_reversion_score,
            price_action_score=price_action_score,
            env_mode=ENV_MODE,
        )

        # (Suggestion 3) If we have no technical setup, do NOT fetch news and do NOT call AI.
        if side == "skip":
            s_result = SentimentResult(
                score=0.0,
                raw_discrete=0,
                rawcompound=0.0,
                ndocuments=0,
                explanation="Skipped AI sentiment due to neutral technical signal.",
                confidence=0.0,
            )
            return Signal(
                symbol=symbol,
                side=side,
                rationale=rationale,
                sentiment_result=s_result,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                signal_score=signal_score,
                momentum_score=momentum_score,
                mean_reversion_score=mean_reversion_score,
                price_action_score=price_action_score,
            )

        # News -> sentiment (Suggestions 1, 2, 6 are enforced inside SentimentModule)
        news_items = self._get_news_items(symbol)
        s_result = self.sentiment.scorenewsitems(symbol, news_items)
        log_sentiment_for_symbol(symbol, s_result, ENV_MODE)

        return Signal(
            symbol=symbol,
            side=side,
            rationale=rationale,
            sentiment_result=s_result,
            stop_price=stop_price,
            take_profit_price=take_profit_price,
            signal_score=signal_score,
            momentum_score=momentum_score,
            mean_reversion_score=mean_reversion_score,
            price_action_score=price_action_score,
        )

-----------

-----------
execution\__init__.py

-----------

-----------
execution\order_executor.py
# execution/order_executor.py

import logging
import time
from typing import Optional

from alpaca_trade_api.rest import APIError
from adapters.alpaca_adapter import AlpacaAdapter
from core.risk_engine import ProposedTrade, PositionInfo
from core.sentiment import SentimentResult
from monitoring.monitor import (
    log_proposed_trade,
    log_sentiment_close_decision,
)
from config.config import ExecutionConfig

logger = logging.getLogger("tradebot")


class OrderExecutor:
    def __init__(
        self,
        adapter: AlpacaAdapter,
        env_mode: str,
        live_trading_enabled: bool,
        execution_cfg: ExecutionConfig,
    ) -> None:
        self.adapter = adapter
        self.env_mode = env_mode
        self.live_trading_enabled = live_trading_enabled
        self.execution_cfg = execution_cfg

    def _can_place_orders(self) -> bool:
        """
        Returns True if it is allowed to place real orders in the current environment.
        PAPER: always True.
        LIVE: only if live_trading_enabled is True.
        """
        if self.env_mode == "LIVE" and not self.live_trading_enabled:
            return False
        return True

    def _wait_for_position(self, symbol: str, timeout_sec: int) -> Optional[any]:
        """
        Wait briefly for the entry to fill so we can submit exit orders safely.
        """
        deadline = time.time() + max(0, int(timeout_sec))
        while time.time() < deadline:
            pos = self.adapter.get_position(symbol)
            if pos is not None:
                return pos
            time.sleep(1)
        return None

    def execute_proposed_trade(self, trade: ProposedTrade):
        # Log the proposed trade with environment mode
        log_proposed_trade(trade, self.env_mode)

        # Skip if rejected or zero qty
        if trade.rejected_reason is not None or trade.qty <= 0:
            return None

        # LIVE dry‑run protection
        if not self._can_place_orders():
            return None

        side = trade.side
        if side not in ("buy", "sell"):
            raise ValueError("side must be 'buy' or 'sell'")

        try:
            # 1) Entry: market order
            entry_order = self.adapter.submit_market_order(
                symbol=trade.symbol,
                qty=trade.qty,
                side=side,
                time_in_force=self.execution_cfg.entry_time_in_force,
            )
        except APIError as e:
            logger.error(f"Entry order placement failed for {trade.symbol}: {e}")
            return None

        # 2) If configured, attempt to place trailing stop + take profit AFTER fill
        if not self.execution_cfg.enable_trailing_stop and not self.execution_cfg.enable_take_profit:
            return entry_order

        pos = self._wait_for_position(trade.symbol, self.execution_cfg.post_entry_fill_timeout_sec)
        if pos is None:
            # Position not visible yet; next loop can protect it via monitoring logic if you add it later.
            return entry_order

        try:
            pos_qty = abs(float(getattr(pos, "qty", 0.0)))
        except Exception:
            pos_qty = abs(trade.qty)

        if pos_qty <= 0:
            return entry_order

        # Determine exit side opposite of entry
        exit_side = "sell" if side == "buy" else "buy"

        # Place Take Profit limit (optional)
        if self.execution_cfg.enable_take_profit:
            tp_price = round(float(trade.take_profit_price), 2)
            try:
                self.adapter.submit_take_profit_limit_order(
                    symbol=trade.symbol,
                    qty=pos_qty,
                    side=exit_side,
                    limit_price=tp_price,
                    time_in_force=self.execution_cfg.exit_time_in_force,
                )
            except APIError as e:
                logger.error(f"Take profit placement failed for {trade.symbol}: {e}")

        # Place Trailing Stop (5% trail by default)
        if self.execution_cfg.enable_trailing_stop:
            try:
                self.adapter.submit_trailing_stop_order(
                    symbol=trade.symbol,
                    qty=pos_qty,
                    side=exit_side,
                    trail_percent=float(self.execution_cfg.trailing_stop_percent),
                    time_in_force=self.execution_cfg.exit_time_in_force,
                )
            except APIError as e:
                logger.error(f"Trailing stop placement failed for {trade.symbol}: {e}")

        return entry_order

    def close_position_due_to_sentiment(
        self,
        position: PositionInfo,
        sentiment: SentimentResult,
        reason: str,
    ):
        """
        Close an existing position immediately because sentiment has flipped strongly against it.

        For a long position, we submit a sell market order of full qty.
        For a short position, we submit a buy market order of full qty.
        """
        log_sentiment_close_decision(
            symbol=position.symbol,
            side=position.side,
            qty=position.qty,
            sentiment_score=sentiment.score,
            confidence=sentiment.confidence,
            explanation=sentiment.explanation,
            env_mode=self.env_mode,
            reason=reason,
        )

        if not self._can_place_orders():
            return None

        if position.qty <= 0:
            return None

        if position.side == "long":
            side = "sell"
        elif position.side == "short":
            side = "buy"
        else:
            raise ValueError(f"Unexpected position side {position.side}")

        try:
            order = self.adapter.rest.submit_order(
                symbol=position.symbol,
                side=side,
                type="market",
                qty=abs(position.qty),
                time_in_force="day",
            )
            return order
        except APIError as e:
            logger.error(f"Close position failed for {position.symbol}: {e}")
            return None


-----------

-----------
execution\position_manager.py
from typing import Dict
from adapters.alpaca_adapter import AlpacaAdapter
from core.risk_engine import PositionInfo


class PositionManager:
    def __init__(self, adapter: AlpacaAdapter):
        self.adapter = adapter

    def get_positions(self) -> Dict[str, PositionInfo]:
        alpaca_positions = self.adapter.list_positions()
        out: Dict[str, PositionInfo] = {}
        for p in alpaca_positions:
            qty = float(p.qty)
            price = float(p.current_price)
            notional = qty * price
            side = "long" if qty > 0 else "short"
            out[p.symbol] = PositionInfo(
                symbol=p.symbol,
                qty=qty,
                market_price=price,
                side=side,
                notional=notional,
            )
        return out

-----------

-----------
main.py
# CHANGES:
#   - BUG FIX: close_position_due_to_sentiment() was fully implemented in OrderExecutor
#     but was never called anywhere in the main loop. This is now fixed.
#   - FEATURE 1: Added sentiment-exit loop that runs BEFORE build_portfolio() each cycle.
#     For every open position the loop:
#       1. Fetches fresh news from Alpaca (up to 10 items).
#       2. Scores sentiment via SentimentModule.scorenewsitems() — respects TTL/chaos
#          cooldown to avoid hammering the AI API unnecessarily.
#       3. Recovers the compound score that was current when the position was opened by
#          reading SentimentModule._cache. If no cached entry exists (bot restart, first
#          loop after cold start) the check is skipped conservatively.
#       4. Computes delta = entry_compound - current_compound (for longs) or
#          current_compound - entry_compound (for shorts).
#       5. If delta >= cfg.sentiment.exit_sentiment_delta_threshold AND current confidence
#          >= cfg.sentiment.exit_confidence_min, calls executor.close_position_due_to_sentiment().
#   - Added import of log_sentiment_for_symbol for use in the exit loop.
#   - No existing variable names, function signatures, or logic paths altered.

import logging
import json
from pathlib import Path
from datetime import datetime, date
import time
from typing import Dict

from config.config import load_config
from adapters.alpaca_adapter import AlpacaAdapter
from core.sentiment import SentimentModule
from core.signals import SignalEngine
from core.risk_engine import RiskEngine, EquitySnapshot, PositionInfo
from core.portfolio_builder import PortfolioBuilder
from execution.position_manager import PositionManager
from execution.order_executor import OrderExecutor
from monitoring.monitor import (
    setup_logging,
    log_equity_snapshot,
    log_environment_switch,
    log_kill_switch_state,
    log_sentiment_for_symbol,
)
from monitoring.kill_switch import KillSwitch

logger = logging.getLogger("tradebot")

_STATE_PATH = Path("data/equity_state.json")


def _load_equity_state() -> Dict[str, float]:
    if not _STATE_PATH.exists():
        return {}
    try:
        with _STATE_PATH.open("r") as f:
            return json.load(f)
    except Exception:
        return {}


def _save_equity_state(state: Dict[str, float]) -> None:
    _STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
    with _STATE_PATH.open("w") as f:
        json.dump(state, f)


def get_equity_snapshot_from_account(acct, positions: Dict[str, PositionInfo]) -> EquitySnapshot:
    equity = float(acct.equity)
    cash = float(acct.cash)
    portfolio_value = float(acct.portfolio_value)

    state = _load_equity_state()
    today_str = date.today().isoformat()

    last_day = state.get("last_trading_day")
    start_of_day_equity = float(state.get("start_of_day_equity", equity))
    high_watermark_equity = float(state.get("high_watermark_equity", equity))

    if last_day != today_str:
        start_of_day_equity = equity
        high_watermark_equity = equity
        state["last_trading_day"] = today_str

    if equity > high_watermark_equity:
        high_watermark_equity = equity

    if start_of_day_equity > 0:
        daily_loss_pct = (equity - start_of_day_equity) / start_of_day_equity
    else:
        daily_loss_pct = 0.0

    if high_watermark_equity > 0:
        drawdown_pct = (equity - high_watermark_equity) / high_watermark_equity
    else:
        drawdown_pct = 0.0

    state["start_of_day_equity"] = start_of_day_equity
    state["high_watermark_equity"] = high_watermark_equity
    _save_equity_state(state)

    realized_pl_today = float(getattr(acct, "daytrade_pl", 0.0))
    unrealized_pl = float(getattr(acct, "unrealized_pl", 0.0))
    gross_exposure = sum(abs(p.notional) for p in positions.values())

    return EquitySnapshot(
        equity=equity,
        cash=cash,
        portfolio_value=portfolio_value,
        day_trading_buying_power=float(acct.daytrading_buying_power),
        start_of_day_equity=start_of_day_equity,
        high_watermark_equity=high_watermark_equity,
        realized_pl_today=realized_pl_today,
        unrealized_pl=unrealized_pl,
        gross_exposure=gross_exposure,
        daily_loss_pct=daily_loss_pct,
        drawdown_pct=drawdown_pct,
    )


def _check_and_exit_on_sentiment(
    positions: Dict[str, PositionInfo],
    adapter: AlpacaAdapter,
    sentiment_module: SentimentModule,
    executor: OrderExecutor,
    cfg,
) -> None:
    """
    For each open position, re-score sentiment from fresh news and compare against
    the compound score that was cached at (or near) entry time.

    Exit logic:
      - LONG position: opened on positive compound. If compound has dropped by
        >= exit_sentiment_delta_threshold AND confidence >= exit_confidence_min → close.
      - SHORT position: opened on negative compound. If compound has risen by
        >= exit_sentiment_delta_threshold AND confidence >= exit_confidence_min → close.

    The entry compound is recovered from SentimentModule._cache (rawcompound field).
    If no cache entry exists for a symbol (cold-start / first loop), the check is
    skipped conservatively — we never exit on missing data.
    """
    delta_threshold = cfg.sentiment.exit_sentiment_delta_threshold
    confidence_min = cfg.sentiment.exit_confidence_min

    for symbol, position in list(positions.items()):
        try:
            # Recover entry-time compound from cache BEFORE rescoring (cache will be
            # overwritten by scorenewsitems if TTL has expired).
            cached_entry = sentiment_module.get_cached_sentiment(symbol)
            if cached_entry is None:
                # No cached entry sentiment — skip rather than false-exit.
                logger.debug(
                    f"SentimentExit [{symbol}]: no cached entry sentiment, skipping check."
                )
                continue

            entry_compound: float = cached_entry.rawcompound

            # Fetch fresh news and rescore. SentimentModule respects TTL and chaos
            # cooldown internally — if TTL is still fresh this returns the cached value,
            # which means delta will be 0 and no exit fires. That is correct behaviour:
            # we only exit when the AI produces a genuinely new adverse reading.
            news_items = adapter.get_news(symbol, limit=10)
            current_sentiment = sentiment_module.scorenewsitems(symbol, news_items)
            log_sentiment_for_symbol(symbol, current_sentiment, cfg.env_mode)

            current_compound: float = current_sentiment.rawcompound
            current_confidence: float = current_sentiment.confidence

            if position.side == "long":
                # Sentiment has moved against a long when compound has fallen.
                delta = entry_compound - current_compound
            elif position.side == "short":
                # Sentiment has moved against a short when compound has risen.
                delta = current_compound - entry_compound
            else:
                continue

            if delta >= delta_threshold and current_confidence >= confidence_min:
                reason = (
                    f"Sentiment compound shifted by {delta:.3f} "
                    f"(entry={entry_compound:.3f} → current={current_compound:.3f}) "
                    f"against {position.side} position; "
                    f"threshold={delta_threshold}, confidence={current_confidence:.2f}"
                )
                executor.close_position_due_to_sentiment(
                    position=position,
                    sentiment=current_sentiment,
                    reason=reason,
                )

        except Exception as exc:
            # Never let a single symbol's exit check crash the whole loop.
            logger.error(
                f"SentimentExit [{symbol}]: unexpected error during exit check: {exc}"
            )


def main():
    setup_logging()
    cfg = load_config()
    log_environment_switch(cfg.env_mode, user="manual_start")

    adapter = AlpacaAdapter(cfg.env_mode)
    sentiment = SentimentModule()
    signal_engine = SignalEngine(adapter, sentiment, cfg.technical)
    risk_engine = RiskEngine(cfg.risk_limits, cfg.sentiment, cfg.instruments)
    pm = PositionManager(adapter)
    executor = OrderExecutor(adapter, cfg.env_mode, cfg.live_trading_enabled, cfg.execution)
    kill_switch = KillSwitch(cfg.risk_limits)
    portfolio_builder = PortfolioBuilder(cfg, adapter, sentiment, signal_engine, risk_engine)

    while True:
        acct = adapter.get_account()
        positions = pm.get_positions()
        snapshot = get_equity_snapshot_from_account(acct, positions)
        market_open = adapter.get_market_open()
        log_equity_snapshot(snapshot, market_open=market_open)

        ks_state = kill_switch.check(snapshot)
        log_kill_switch_state(ks_state)
        if ks_state.halted:
            time.sleep(60)
            continue

        # --- SENTIMENT-DRIVEN EXIT ON OPEN POSITIONS (Feature 1 / Bug Fix) ---
        # Runs unconditionally every loop (kill switch already cleared above).
        # Must execute BEFORE the exposure guard below so that exits free up
        # capacity and the bot can re-enter in the same cycle if appropriate.
        if positions:
            _check_and_exit_on_sentiment(
                positions=positions,
                adapter=adapter,
                sentiment_module=sentiment,
                executor=executor,
                cfg=cfg,
            )
            # Refresh positions after potential closes so the exposure guard and
            # portfolio builder work against the post-exit state.
            positions = pm.get_positions()
            snapshot = get_equity_snapshot_from_account(acct, positions)

        exposure_cap_notional = snapshot.equity * cfg.risk_limits.gross_exposure_cap_pct

        # --- NO EQUITY GUARD ---
        if snapshot.gross_exposure >= exposure_cap_notional or len(positions) >= cfg.risk_limits.max_open_positions:
            time.sleep(60)
            continue

        # Fetch open orders to prevent duplicates and pass to portfolio builder
        open_orders = adapter.list_orders(status="open")

        proposed_trades = portfolio_builder.build_portfolio(snapshot, positions, open_orders)

        from monitoring.monitor import log_portfolio_overview  # local import to avoid cycles
        log_portfolio_overview(proposed_trades, cfg.env_mode)

        for proposed in proposed_trades:
            executor.execute_proposed_trade(proposed)

        time.sleep(600)


if __name__ == "__main__":
    main()






-----------

-----------
monitoring\__init__.py

-----------

-----------
monitoring\kill_switch.py
from dataclasses import dataclass
from config.config import RiskLimits
from core.risk_engine import EquitySnapshot


@dataclass
class KillSwitchState:
    halted: bool
    reason: str


class KillSwitch:
    def __init__(self, limits: RiskLimits):
        self.limits = limits

    def check(self, snapshot: EquitySnapshot) -> KillSwitchState:
        if snapshot.daily_loss_pct <= -self.limits.daily_loss_limit_pct:
            return KillSwitchState(True, "Daily loss limit hit")
        if snapshot.drawdown_pct <= -self.limits.max_drawdown_pct:
            return KillSwitchState(True, "Max drawdown limit hit")
        return KillSwitchState(False, "")

-----------

-----------
monitoring\monitor.py
# monitoring/monitor.py
import logging
from datetime import datetime
from typing import List

from core.risk_engine import EquitySnapshot, ProposedTrade
from core.sentiment import SentimentResult
from monitoring.kill_switch import KillSwitchState

logger = logging.getLogger("tradebot")

RESET        = "\033[0m"
LINEBLUE     = "\033[38;2;138;185;241m"
LINEYELLOW   = "\033[38;2;248;222;126m"
SEPCOLOR     = "\033[38;2;222;211;151m"
SIGNALRED    = "\033[38;2;220;53;69m"
SIGNALGREEN  = "\033[38;2;40;167;69m"
ITALICON     = "\033[3m"
ITALICOFF    = "\033[23m"
BRIGHTPURPLE = "\033[38;2;191;64;191m"
DEEPBLUE     = "\033[38;2;0;13;222m"

# Market status colours
MARKETOPEN   = "\033[38;2;40;167;69m"   # green  - same hue as SIGNALGREEN
MARKETCLOSED = "\033[38;2;220;53;69m"   # red    - same hue as SIGNALRED

_linetoggle = 0

def next_line_color() -> str:
    global _linetoggle
    _linetoggle = 0 if _linetoggle == 1 else 1
    return LINEBLUE if _linetoggle == 0 else LINEYELLOW


def separator_line() -> str:
    return f"{SEPCOLOR}" + "-" * 80 + f"{RESET}"


def sentiment_score_fragment(score: float, line_color: str) -> str:
    base = "sentiment="
    if score <= -0.5:
        return f"{base}{SIGNALRED}{score:.3f}{line_color}"
    if score >= 0.5:
        return f"{base}{SIGNALGREEN}{score:.3f}{line_color}"
    return f"{base}{score:.3f}"


def italicize_technical(text: str) -> str:
    if not text:
        return text
    terms = [
        "RSI", "MACD", "moving average", "moving averages", "EMA", "SMA",
        "Bollinger", "support", "resistance", "candles", "candle", "bar", "bars",
    ]
    out = text
    for term in terms:
        out = out.replace(term, f"{ITALICON}{term}{ITALICOFF}")
    return out


def setup_logging() -> None:
    logging.basicConfig(level=logging.INFO, format="%(message)s")


def log_environment_switch(env_mode: str, user: str) -> None:
    line_color = next_line_color()
    msg = f"{datetime.utcnow().isoformat()}Z ENV switch event: mode={env_mode}, user={user}"
    logger.warning(f"{line_color}{msg}{RESET}")


def log_equity_snapshot(snapshot: EquitySnapshot, market_open: bool = False) -> None:
    """
    Logs the equity snapshot with a coloured MARKET OPEN / MARKET CLOSED badge.
    """
    line_color = next_line_color()

    if market_open:
        market_badge = f"{MARKETOPEN}[MARKET OPEN]{line_color}"
    else:
        market_badge = f"{MARKETCLOSED}[MARKET CLOSED]{line_color}"

    msg = (
        f"{datetime.utcnow().isoformat()}Z EquitySnapshot: "
        f"{market_badge} "
        f"equity={snapshot.equity:.2f}, "
        f"cash={snapshot.cash:.2f}, "
        f"gross_exposure={snapshot.gross_exposure:.2f}, "
        f"daily_loss_pct={snapshot.daily_loss_pct:.3f}, "
        f"drawdown_pct={snapshot.drawdown_pct:.3f}"
    )
    logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


def log_kill_switch_state(state: KillSwitchState) -> None:
    line_color = next_line_color()
    if state.halted:
        msg = f"{datetime.utcnow().isoformat()}Z KILL-SWITCH ACTIVATED: {state.reason}"
        logger.error(f"{line_color}{msg}{RESET}")
    else:
        msg = f"{datetime.utcnow().isoformat()}Z Kill-switch OK"
        logger.debug(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


def log_sentiment_for_symbol(symbol: str, sentiment: SentimentResult, env_mode: str) -> None:
    line_color = next_line_color()
    score_frag = sentiment_score_fragment(sentiment.score, line_color)
    expl_raw = (sentiment.explanation or "").replace("\n", " ").strip()
    expl_fmt = italicize_technical(expl_raw)
    symbol_part = f"{BRIGHTPURPLE}{symbol}{line_color}"
    msg = (
        f"{datetime.utcnow().isoformat()}Z {env_mode} Sentiment "
        f"symbol={symbol_part} "
        f"{score_frag} "
        f"conf={sentiment.confidence:.2f} "
        f"docs={sentiment.ndocuments} "
        f"reason={expl_fmt}"
    )
    logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


def log_signal_score(
    symbol: str,
    signal_score: float,
    momentum_score: float,
    mean_reversion_score: float,
    price_action_score: float,
    env_mode: str,
) -> None:
    line_color = next_line_color()
    symbol_part = f"{BRIGHTPURPLE}{symbol}{line_color}"
    composite_str = f"{BRIGHTPURPLE}{signal_score:.3f}{line_color}"
    msg = (
        f"{datetime.utcnow().isoformat()}Z {env_mode} Signal "
        f"symbol={symbol_part} "
        f"{ITALICON}composite={composite_str}{ITALICOFF} "
        f"{ITALICON}momentum={momentum_score:.3f}{ITALICOFF} "
        f"{ITALICON}mean_reversion={mean_reversion_score:.3f}{ITALICOFF} "
        f"{ITALICON}price_action={price_action_score:.3f}{ITALICOFF}"
    )
    logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


def log_proposed_trade(trade: ProposedTrade, env_mode: str) -> None:
    line_color = next_line_color()
    sentiment_part = sentiment_score_fragment(trade.sentiment_score, line_color)
    action_tag = ""
    if trade.rejected_reason is None and trade.qty > 0:
        if trade.side == "buy":
            action_tag = f" {SIGNALGREEN}BUY{line_color}"
        elif trade.side == "sell":
            action_tag = f" {SIGNALRED}SELL{line_color}"
    notional = trade.qty * trade.entry_price
    symbol_part = f"{BRIGHTPURPLE}{trade.symbol}{line_color}"
    sig_part = f"{BRIGHTPURPLE}{trade.signal_score:.3f}{line_color}"
    msg = (
        f"{datetime.utcnow().isoformat()}Z {env_mode} ProposedTrade "
        f"symbol={symbol_part} {trade.side} "
        f"qty={trade.qty:.4f} notional={notional:.2f} "
        f"entry={trade.entry_price:.4f} stop={trade.stop_price:.4f} tp={trade.take_profit_price:.4f} "
        f"risk_amt={trade.risk_amount:.2f} risk_pct={trade.risk_pct_of_equity:.4f} "
        f"{sentiment_part} scale={trade.sentiment_scale:.3f} "
        f"rejected={trade.rejected_reason} "
        f"{action_tag} "
        f"{sig_part}"
    )
    logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


def log_sentiment_close_decision(
    symbol: str,
    side: str,
    qty: float,
    sentiment_score: float,
    confidence: float,
    explanation: str,
    env_mode: str,
    reason: str,
) -> None:
    line_color = next_line_color()
    score_frag = sentiment_score_fragment(sentiment_score, line_color)
    expl_raw = (explanation or "").replace("\n", " ").strip()
    expl_fmt = italicize_technical(expl_raw)
    force_msg = f"{SIGNALRED}FORCE-CLOSED DUE TO BAD SENTIMENT{line_color}"
    symbol_part = f"{BRIGHTPURPLE}{symbol}{line_color}"
    msg = (
        f"{datetime.utcnow().isoformat()}Z {env_mode} SentimentExit "
        f"symbol={symbol_part} side={side} qty={qty:.4f} "
        f"{score_frag} conf={confidence:.2f} "
        f"reason_for_exit={reason} "
        f"{force_msg} "
        f"{expl_fmt}"
    )
    logger.warning(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


def log_portfolio_overview(trades: List[ProposedTrade], env_mode: str) -> None:
    logger.info(separator_line())
    if not trades:
        header = f"{datetime.utcnow().isoformat()}Z {env_mode} PORTFOLIO OVERVIEW"
        logger.info(f"{DEEPBLUE}{header}{RESET}")
        logger.info(f"{DEEPBLUE}No new trades selected in this cycle.{RESET}")
        logger.info(separator_line())
        return

    line_color = next_line_color()
    header = f"{datetime.utcnow().isoformat()}Z {env_mode} PORTFOLIO OVERVIEW"
    logger.info(f"{line_color}{header}{RESET}")
    for t in trades:
        notional = t.qty * t.entry_price
        symbol_part = f"{BRIGHTPURPLE}{t.symbol}{line_color}"
        sig_str = f"{BRIGHTPURPLE}{t.signal_score:.3f}{line_color}"
        msg = (
            f"  symbol={symbol_part} side={t.side} "
            f"qty={t.qty:.4f} notional={notional:.2f} "
            f"signal_score={sig_str} "
            f"rejected={t.rejected_reason}"
        )
        logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())

def log_startup_banner(env_mode: str) -> None:
    logger.info(separator_line())
    logger.info(f"{DEEPBLUE}   TRADE BOT STARTING UP   {RESET}")
    logger.info(f"{DEEPBLUE}   Environment: {env_mode} {RESET}")
    logger.info(separator_line())






















-----------

-----------
requirements.txt
alpaca-trade-api>=3.0.0
PyYAML>=6.0
vaderSentiment>=3.3.2
pytz>=2024.1

-----------

-----------
tests\__init__.py

-----------

-----------
todo.txt
1----------------------------------------------------------------------------------

prevent repeated orders in next loop, when position for instrument is still open.

2----------------------------------------------------------------------------------

Scrap upper and lower resistance with AI and use it in a viable capacity

3----------------------------------------------------------------------------------

test with different weights in composit value

4----------------------------------------------------------------------------------

tweak lot size based on weights

5----------------------------------------------------------------------------------

improve portfolio composition for better diversification

6----------------------------------------------------------------------------------

thats lowkey and highkey it
-----------

