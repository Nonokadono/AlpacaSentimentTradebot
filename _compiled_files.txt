-----------
adapters\__init__.py

-----------

-----------
adapters\alpaca_adapter.py
# adapters/alpaca_adapter.py
import os
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

import alpaca_trade_api as tradeapi


class AlpacaAdapter:
    """
    Thin adapter around Alpaca REST API, configured purely by env vars:
    APCA_API_BASE_URL
    APCA_API_KEY_ID
    APCA_API_SECRET_KEY
    """

    def __init__(self, env_mode: str):
        self.env_mode = env_mode
        base_url = os.getenv("APCA_API_BASE_URL", "https://paper-api.alpaca.markets")
        key_id = os.getenv("APCA_API_KEY_ID")
        secret_key = os.getenv("APCA_API_SECRET_KEY")
        if not key_id or not secret_key:
            raise ValueError("APCA_API_KEY_ID and APCA_API_SECRET_KEY must be set")

        self.rest = tradeapi.REST(
            key_id=key_id,
            secret_key=secret_key,
            base_url=base_url,
            api_version="v2",
        )

    # --- Account / positions ---

    def get_account(self) -> Any:
        return self.rest.get_account()

    def list_positions(self) -> List[Any]:
        return list(self.rest.list_positions() or [])

    def get_position(self, symbol: str) -> Optional[Any]:
        try:
            return self.rest.get_position(symbol)
        except Exception:
            return None

    # --- Market status ---

    def get_market_open(self) -> bool:
        """
        Returns True if the US equity market is currently open, False otherwise.
        Uses Alpaca's /v2/clock endpoint.
        """
        try:
            clock = self.rest.get_clock()
            return bool(clock.is_open)
        except Exception:
            return False

    # --- Market data ---

    def get_last_quote(self, symbol: str) -> float:
        """
        Get a close/last price proxy via recent bars, fallback to latest trade.
        """
        end = datetime.utcnow()
        start = end - timedelta(minutes=60)

        try:
            bars = self.rest.get_bars(
                symbol,
                "5Min",
                start.isoformat() + "Z",
                end.isoformat() + "Z",
            )
        except Exception as e:
            print(f"get_bars error for {symbol}: {e}")
            bars = []

        if not bars:
            last = self.rest.get_latest_trade(symbol)
            return float(last.price)

        bar = bars[-1]
        close_price = getattr(bar, "c", None)
        if close_price is None:
            close_price = bar.c

        return float(close_price)

    def get_recent_bars(
        self,
        symbol: str,
        timeframe: str = "5Min",
        lookback_bars: int = 30,
    ) -> List[Any]:
        end = datetime.utcnow()
        start = end - timedelta(minutes=lookback_bars * 5 + 30)
        try:
            bars = self.rest.get_bars(
                symbol,
                timeframe,
                start.isoformat() + "Z",
                end.isoformat() + "Z",
                limit=lookback_bars,
            )
        except Exception as e:
            print(f"get_recent_bars error for {symbol}: {e}")
            bars = []
        return list(bars or [])

    # --- News / sentiment inputs ---

    def get_news(
        self,
        symbol: str,
        since: Optional[datetime] = None,
        limit: int = 20,
    ) -> List[Dict[str, str]]:
        try:
            kwargs: Dict[str, Any] = {"symbol": symbol, "limit": limit}
            if since is not None:
                kwargs["start"] = since.isoformat() + "Z"
            raw_items = self.rest.get_news(**kwargs)
        except Exception as e:
            print(f"get_news error for {symbol}: {e}")
            return []

        out: List[Dict[str, str]] = []
        for n in raw_items:
            headline = getattr(n, "headline", "") or ""
            summary = getattr(n, "summary", "") or ""
            out.append({"headline": headline, "summary": summary})
        return out

    # --- Orders ---

    def submit_market_order(
        self,
        symbol: str,
        qty: float,
        side: str,
        time_in_force: str = "day",
    ) -> Any:
        return self.rest.submit_order(
            symbol=symbol,
            side=side,
            type="market",
            qty=qty,
            time_in_force=time_in_force,
        )

    def submit_take_profit_limit_order(
        self,
        symbol: str,
        qty: float,
        side: str,
        limit_price: float,
        time_in_force: str = "day",
    ) -> Any:
        return self.rest.submit_order(
            symbol=symbol,
            side=side,
            type="limit",
            qty=qty,
            limit_price=limit_price,
            time_in_force=time_in_force,
        )

    def submit_trailing_stop_order(
        self,
        symbol: str,
        qty: float,
        side: str,
        trail_percent: float,
        time_in_force: str = "day",
    ) -> Any:
        return self.rest.submit_order(
            symbol=symbol,
            side=side,
            type="trailing_stop",
            qty=qty,
            trail_percent=trail_percent,
            time_in_force=time_in_force,
        )

    def cancel_order(self, order_id: str) -> None:
        self.rest.cancel_order(order_id)

    def cancel_all_orders(self) -> None:
        self.rest.cancel_all_orders()

    def close_all_positions(self) -> None:
        self.rest.close_all_positions()

    def list_orders(self, status: str = "open") -> List[Any]:
        return list(self.rest.list_orders(status=status) or [])



-----------

-----------
ai_client.py
# aiclient.py
import json
import os
import requests


class NewsReasoner:
    """
    Uses Perplexity's Chat Completions API (OpenAI-compatible with the sonar model)
    to score short-term news sentiment.

    Returns a dict with keys:
        - sentiment: int in {-2, -1, 0, 1}
        - confidence: float in [0, 1]
        - explanation: str
    """

    def __init__(self) -> None:
        # Read directly from environment variables
        self.apiurl = os.getenv("AI_API_URL", "https://api.perplexity.ai/chat/completions")
        self.apikey = os.getenv("AI_API_KEY")
        if not self.apikey:
            raise RuntimeError("AI_API_KEY is not set. Please export your Perplexity API key.")

    def scorenews(self, symbol: str, newsitems):
        """
        Input:
            symbol: string ticker, e.g. "AAPL"
            newsitems: list of dicts from Alpaca news API

        Output dict:
            - sentiment: -2, -1, 0, or 1
            - confidence: float 0-1
            - explanation: str
        """
        try:
            # No news -> neutral, low confidence
            if not newsitems:
                return {
                    "sentiment": 0,
                    "confidence": 0.0,
                    "explanation": "No recent news."
                }

            # Build compact headlines + summaries for up to 10 news items
            summaries = []
            for n in newsitems[:10]:
                title = n.get("headline") or n.get("title") or ""
                summary = n.get("summary") or ""
                text = f"{title} {summary}".strip()
                if not text:
                    continue
                summaries.append(text[:300])
            if not summaries:
                return {
                    "sentiment": 0,
                    "confidence": 0.0,
                    "explanation": "No usable news text."
                }

            userprompt = (
                f"You are a professional equity analyst.\n"
                f"Evaluate the SHORT-TERM (next few trading days) impact of the following news "
                f"on {symbol} stock.\n"
                f"Return a single JSON object with keys:\n"
                f'  sentiment: -2, -1, 0, or 1\n'
                f'    -2 for extremely unstable / utterly undesirable to trade now (e.g. chaotic, '
                f'        very high uncertainty, extreme event risk),\n'
                f'    -1 for clearly negative,\n'
                f'     0 for neutral or mixed,\n'
                f'     1 for clearly positive.\n'
                f'  confidence: a number between 0 and 1\n'
                f'  explanation: short textual explanation (1-3 sentences).\n\n'
                f"News:\n- " + "\n- ".join(summaries)
            )

            headers = {
                "Authorization": f"Bearer {self.apikey}",
                "Content-Type": "application/json",
            }
            payload = {
                "model": "sonar",
                "messages": [
                    {
                        "role": "system",
                        "content": (
                            "You are a precise financial sentiment classifier. "
                            "You only output strict JSON with the requested keys."
                        ),
                    },
                    {
                        "role": "user",
                        "content": userprompt,
                    },
                ],
                "temperature": 0.1,
                "max_tokens": 300,
            }

            resp = requests.post(self.apiurl, headers=headers, json=payload, timeout=30)
            if not resp.ok:
                # Log error and degrade gracefully to neutral sentiment
                print("Perplexity error", resp.status_code, resp.text)
                return {
                    "sentiment": 0,
                    "confidence": 0.0,
                    "explanation": "Error from AI API, treating sentiment as neutral.",
                }

            data = resp.json()
            rawcontent = data["choices"][0]["message"]["content"].strip()

            # Expect JSON, fallback to extracting JSON substring if needed
            try:
                result = json.loads(rawcontent)
            except json.JSONDecodeError:
                try:
                    start = rawcontent.index("{")
                    end = rawcontent.rindex("}") + 1
                    result = json.loads(rawcontent[start:end])
                except Exception:
                    return {
                        "sentiment": 0,
                        "confidence": 0.0,
                        "explanation": "Could not parse model output, treating as neutral.",
                    }

            sentiment = result.get("sentiment", 0)
            # Normalize sentiment to allowed set {-2, -1, 0, 1}
            if sentiment not in (-2, -1, 0, 1):
                sentiment = 0

            try:
                confidence = float(result.get("confidence", 0.0))
            except (TypeError, ValueError):
                confidence = 0.0
            confidence = max(0.0, min(1.0, confidence))

            explanation = result.get("explanation", "")

            return {
                "sentiment": sentiment,
                "confidence": confidence,
                "explanation": explanation,
            }

        except Exception as e:
            # Normalize fields on any unexpected error
            print("scorenews error", e)
            return {
                "sentiment": 0,
                "confidence": 0.0,
                "explanation": "Exception in sentiment analysis, treating as neutral.",
            }


-----------

-----------
config\__init__.py

-----------

-----------
config\config.py
# CHANGES:
#   - SentimentConfig: added exit_sentiment_delta_threshold (default 0.7) and
#     exit_confidence_min (default 0.5).
#     These gate the sentiment-driven forced-exit logic in main.py.
#     Both are additive fields with defaults; no existing field touched.

import os
import yaml
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import Dict


ENV_MODE = os.getenv("APCA_API_ENV", "PAPER").upper()
if ENV_MODE not in ("PAPER", "LIVE"):
    raise ValueError(f"Invalid APCA_API_ENV={ENV_MODE}, expected PAPER or LIVE")

LIVE_TRADING_ENABLED = os.getenv("LIVE_TRADING_ENABLED", "false").lower() == "true"


@dataclass
class RiskLimits:
    max_risk_per_trade_pct: float = 0.03     # 3% of equity (was 1%)
    min_risk_per_trade_pct: float = 0.005    # 0.5% of equity
    gross_exposure_cap_pct: float = 0.90     # 90% of equity
    daily_loss_limit_pct: float = 0.04       # 4% of start-of-day equity
    max_drawdown_pct: float = 0.09           # 9% from high watermark
    max_open_positions: int = 15


@dataclass
class SentimentConfig:
    neutral_band: float = 0.1
    min_scale: float = 0.2
    max_scale: float = 1.3
    no_trade_negative_threshold: float = -0.4
    # --- Sentiment-exit thresholds (Feature 1) ---
    # Minimum absolute shift in sentiment compound score required to trigger a forced exit.
    # A position opened when compound was +0.8 and now scoring +0.05 yields delta = 0.75 → exit.
    exit_sentiment_delta_threshold: float = 0.7
    # Minimum model confidence in the *current* (adverse) sentiment reading before we act on it.
    # Prevents low-confidence noise from closing profitable positions.
    exit_confidence_min: float = 0.5


@dataclass
class TechnicalSignalConfig:
    weight_momentum_trend: float = 0.5
    weight_mean_reversion: float = 0.3
    weight_price_action: float = 0.2
    long_threshold: float = 0.2
    short_threshold: float = -0.2
    momentum_norm_scale: float = 0.05
    ma_distance_norm_scale: float = 0.05
    rsi_overbought: float = 70.0
    rsi_oversold: float = 30.0
    breakout_lookback_bars: int = 20
    breakout_strength: float = 1.0
    base_stop_vol_mult: float = 1.5
    base_tp_vol_mult: float = 3.0
    max_tp_scale_from_signal: float = 1.3
    min_tp_scale_from_signal: float = 0.7


@dataclass
class ExecutionConfig:
    enable_trailing_stop: bool = True
    trailing_stop_percent: float = 5.0   # 5% trailing distance
    enable_take_profit: bool = True
    exit_time_in_force: str = "day"
    entry_time_in_force: str = "day"
    post_entry_fill_timeout_sec: int = 15


@dataclass
class InstrumentMeta:
    symbol: str
    exchange: str
    lot_size: float
    fractional: bool
    shortable: bool
    marginable: bool
    trading_hours: str
    sector: str = "UNKNOWN"


@dataclass
class PortfolioConfig:
    enable_portfolio_veto: bool = False
    max_candidates_per_loop: int = 50


@dataclass
class BotConfig:
    env_mode: str
    live_trading_enabled: bool
    risk_limits: RiskLimits
    sentiment: SentimentConfig
    technical: TechnicalSignalConfig
    execution: ExecutionConfig
    instruments: Dict[str, InstrumentMeta]
    portfolio: PortfolioConfig


@dataclass
class AIConfig:
    api_url: str
    api_key: str


def _load_instrument_whitelist(path: Path) -> Dict[str, InstrumentMeta]:
    if not path.exists():
        raise FileNotFoundError(f"Instrument whitelist not found at {path}")
    with path.open("r") as f:
        data = yaml.safe_load(f) or {}
    instruments: Dict[str, InstrumentMeta] = {}
    for sym, meta in data.items():
        instruments[sym] = InstrumentMeta(
            symbol=sym,
            exchange=meta.get("exchange", "NYSE"),
            lot_size=float(meta.get("lot_size", 1)),
            fractional=bool(meta.get("fractional", False)),
            shortable=bool(meta.get("shortable", False)),
            marginable=bool(meta.get("marginable", False)),
            trading_hours=meta.get("trading_hours", "09:30-16:00"),
            sector=meta.get("sector", "UNKNOWN"),
        )
    return instruments


def load_config() -> BotConfig:
    base = Path(__file__).resolve().parents[1]
    wl_path = base / "config" / "instrument_whitelist.yaml"
    instruments = _load_instrument_whitelist(wl_path)

    risk = RiskLimits()
    sentiment = SentimentConfig()
    technical = TechnicalSignalConfig()
    execution = ExecutionConfig()
    portfolio = PortfolioConfig()

    cfg = BotConfig(
        env_mode=ENV_MODE,
        live_trading_enabled=LIVE_TRADING_ENABLED,
        risk_limits=risk,
        sentiment=sentiment,
        technical=technical,
        execution=execution,
        instruments=instruments,
        portfolio=portfolio,
    )
    return cfg


if __name__ == "__main__":
    cfg = load_config()
    print(asdict(cfg))



-----------

-----------
config\instrument_whitelist.yaml
# CHANGES:
# - Feature 2: Added `sector` label to every instrument.
#   Labels: TECH, ETF_INDEX, ETF_SECTOR, FINANCE, CONSUMER, ENERGY, FX.
#   No existing keys renamed or removed.

AAPL:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

MSFT:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

GOOGL:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

AMZN:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

NVDA:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

META:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

TSLA:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

AMD:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

MU:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

NFLX:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: TECH

#SPY:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: ETF_INDEX

#QQQ:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: ETF_INDEX

#VOO:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: ETF_INDEX

#IWM:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: ETF_INDEX

#XLF:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: ETF_SECTOR

#XLE:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: ETF_SECTOR

#SLV:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: ETF_SECTOR

#EEM:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: ETF_INDEX

#BAC:
  exchange: NYSE
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: FINANCE

#COST:
  exchange: NASDAQ
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: CONSUMER

#FXE:
  exchange: ARCA
  lot_size: 1
  fractional: true
  shortable: true
  marginable: true
  trading_hours: "0930-1600"
  sector: FX  # EUR vs USD proxy

-----------

-----------
core\__init__.py

-----------

-----------
core\portfolio_builder.py
# core/portfolio_builder.py

from typing import Dict, List, Any

from adapters.alpaca_adapter import AlpacaAdapter
from core.signals import SignalEngine, Signal
from core.sentiment import SentimentModule
from core.risk_engine import RiskEngine, EquitySnapshot, PositionInfo, ProposedTrade
from config.config import BotConfig
from .portfolio_veto import PortfolioVeto


class PortfolioBuilder:
    """
    Portfolio-level builder:
    - Compute signal_score and side for each instrument.
    - Run pre_trade_checks -> ProposedTrade.
    - Rank by |signal_score| and select until portfolio limits are hit.
    - Optional Sonar veto.
    """

    def __init__(
        self,
        cfg: BotConfig,
        adapter: AlpacaAdapter,
        sentiment: SentimentModule,
        signal_engine: SignalEngine,
        risk_engine: RiskEngine,
    ) -> None:
        self.cfg = cfg
        self.adapter = adapter
        self.sentiment = sentiment
        self.signal_engine = signal_engine
        self.risk_engine = risk_engine
        self.veto = PortfolioVeto()

    def _build_candidate_for_symbol(
        self,
        symbol: str,
        snapshot: EquitySnapshot,
        positions: Dict[str, PositionInfo],
        pending_symbols: set,
    ) -> ProposedTrade:
        
        # --- DUPLICATE-ORDER & NO EQUITY GUARD ---
        # If we already hold a position in this symbol, skip immediately (no AI API calls).
        if symbol in positions:
            return ProposedTrade(
                symbol=symbol,
                side="buy",
                qty=0.0,
                entry_price=0.0,
                stop_price=0.0,
                take_profit_price=0.0,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=0.0,
                sentiment_scale=0.0,
                signal_score=0.0,
                rationale="Position already open for this symbol",
                rejected_reason="Position already open; skipping to prevent duplicate order and save API calls",
            )
            
        # If an order is already pending, skip immediately (no AI API calls).
        if symbol in pending_symbols:
            return ProposedTrade(
                symbol=symbol,
                side="buy",
                qty=0.0,
                entry_price=0.0,
                stop_price=0.0,
                take_profit_price=0.0,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=0.0,
                sentiment_scale=0.0,
                signal_score=0.0,
                rationale="Pending order exists for this symbol",
                rejected_reason="Pending order exists; skipping to prevent duplicate order and save API calls",
            )

        # Signal Engine is queried AFTER validation, saving an AI API call if conditions are unmet.
        sig: Signal = self.signal_engine.generate_signal_for_symbol(symbol)

        if sig.side == "skip":
            return ProposedTrade(
                symbol=sig.symbol,
                side="buy",
                qty=0.0,
                entry_price=0.0,
                stop_price=0.0,
                take_profit_price=0.0,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sig.sentiment_result.score,
                sentiment_scale=0.0,
                signal_score=sig.signal_score,
                rationale=sig.rationale,
                rejected_reason="Signal neutral/skip",
            )

        entry_price = self.adapter.get_last_quote(symbol)

        proposed = self.risk_engine.pre_trade_checks(
            snapshot=snapshot,
            positions=positions,
            symbol=sig.symbol,
            side=sig.side,
            entry_price=entry_price,
            stop_price=sig.stop_price,
            take_profit_price=sig.take_profit_price,
            sentiment=sig.sentiment_result,
            signal_score=sig.signal_score,
            rationale=sig.rationale,
        )
        return proposed

    def build_portfolio(
        self,
        snapshot: EquitySnapshot,
        positions: Dict[str, PositionInfo],
        open_orders: List[Any],
    ) -> List[ProposedTrade]:
        
        # Defense-in-depth: if fully allocated globally, skip all portfolio generation.
        exposure_cap_notional = snapshot.equity * self.cfg.risk_limits.gross_exposure_cap_pct
        if snapshot.gross_exposure >= exposure_cap_notional or len(positions) >= self.cfg.risk_limits.max_open_positions:
            return []

        pending_symbols = {getattr(o, "symbol", "") for o in open_orders if hasattr(o, "symbol")}

        symbols = list(self.cfg.instruments.keys())
        max_candidates = self.cfg.portfolio.max_candidates_per_loop
        if max_candidates > 0:
            symbols = symbols[:max_candidates]

        candidates: List[ProposedTrade] = []
        for sym in symbols:
            candidate = self._build_candidate_for_symbol(sym, snapshot, positions, pending_symbols)
            candidates.append(candidate)

        feasible: List[ProposedTrade] = [
            t for t in candidates if t.qty > 0 and t.rejected_reason is None
        ]
        if not feasible:
            return []

        feasible.sort(key=lambda t: abs(t.signal_score), reverse=True)

        selected: List[ProposedTrade] = []
        current_gross = snapshot.gross_exposure
        current_open_positions = len(positions)

        for t in feasible:
            # Secondary guard (defensive): never select a symbol already in positions.
            if t.symbol in positions:
                continue

            notional = t.qty * t.entry_price
            projected_gross = current_gross + abs(notional)

            if projected_gross > snapshot.equity * self.cfg.risk_limits.gross_exposure_cap_pct:
                continue

            new_symbol = t.symbol not in positions
            projected_positions = current_open_positions + (1 if new_symbol else 0)
            if projected_positions > self.cfg.risk_limits.max_open_positions:
                continue

            selected.append(t)
            current_gross = projected_gross
            if new_symbol:
                current_open_positions = projected_positions

        if not selected:
            return []

        if self.cfg.portfolio.enable_portfolio_veto:
            selected = self.veto.apply_veto(selected)

        return selected


-----------

-----------
core\portfolio_veto.py
# core/portfolio_veto.py
import json
import os
from typing import Dict, List

import requests

from core.risk_engine import ProposedTrade


class PortfolioVeto:
    """
    Optional portfolio-level veto layer using Perplexity Sonar.

    Given a list of ProposedTrade candidates (already risk-checked),
    prepares a compact prompt and expects a JSON mapping symbol -> 0/1,
    where 0 means veto (do not trade), 1 means allow.

    Controlled by config.portfolio.enable_portfolio_veto.
    """

    def __init__(self) -> None:
        self.apiurl = os.getenv("AI_API_URL", "https://api.perplexity.ai/chat/completions")
        self.apikey = os.getenv("AI_API_KEY")
        if not self.apikey:
            # Fail soft: without API key, veto layer is effectively a no-op
            self.disabled = True
        else:
            self.disabled = False

    def _build_prompt(self, trades: List[ProposedTrade]) -> str:
        lines = []
        for t in trades:
            notional = t.qty * t.entry_price
            line = {
                "symbol": t.symbol,
                "side": t.side,
                "notional": round(notional, 2),
                "signal_score": round(t.signal_score, 3),
                "sentiment_score": round(t.sentiment_score, 3),
                "reason": (t.rationale or "")[:200],
            }
            lines.append(line)

        return (
            "You are a risk-aware portfolio reviewer.\n"
            "You will receive a list of proposed short-term trades for US equities.\n"
            "Each trade includes symbol, side, notional size, a technical signal_score in [-1,1],\n"
            "and a sentiment_score in [-1,1].\n\n"
            "Your task: return a single JSON object mapping each symbol to 0 or 1.\n"
            "1 = trade is acceptable, 0 = veto due to extreme risk, obvious conflict, or\n"
            "major concern (e.g. very unstable situation, illogical rationale).\n"
            "Be conservative but do NOT overfit; use 0 only for clearly problematic trades.\n\n"
            "Input trades:\n"
            + json.dumps(lines, indent=2)
        )

    def apply_veto(self, trades: List[ProposedTrade]) -> List[ProposedTrade]:
        if self.disabled or not trades:
            return trades

        prompt = self._build_prompt(trades)
        headers = {
            "Authorization": f"Bearer {self.apikey}",
            "Content-Type": "application/json",
        }
        payload = {
            "model": "sonar",
            "messages": [
                {
                    "role": "system",
                    "content": (
                        "You are a precise portfolio veto engine. "
                        "You only output strict JSON with {symbol: 0 or 1} entries."
                    ),
                },
                {
                    "role": "user",
                    "content": prompt,
                },
            ],
            "temperature": 0.1,
            "max_tokens": 400,
        }

        try:
            resp = requests.post(self.apiurl, headers=headers, json=payload, timeout=30)
            if not resp.ok:
                print("PortfolioVeto API error", resp.status_code, resp.text)
                return trades

            data = resp.json()
            rawcontent = data["choices"][0]["message"]["content"].strip()
            try:
                result = json.loads(rawcontent)
            except json.JSONDecodeError:
                start = rawcontent.find("{")
                end = rawcontent.rfind("}")
                if start == -1 or end == -1:
                    return trades
                result = json.loads(rawcontent[start : end + 1])

            allowed: List[ProposedTrade] = []
            for t in trades:
                flag = result.get(t.symbol, 1)
                try:
                    flag_int = int(flag)
                except (TypeError, ValueError):
                    flag_int = 1
                if flag_int == 1:
                    allowed.append(t)
            return allowed
        except Exception as e:
            print("PortfolioVeto exception", e)
            return trades

-----------

-----------
core\risk_engine.py
# CHANGES:
#   - Feature 3 — Half-Kelly position sizing:
#     pre_trade_checks() now accepts two new keyword arguments:
#       volatility: float = 0.0  — per-symbol return std-dev from SignalEngine._compute_volatility()
#       sentiment_scale_override: float = -1.0  — allows the caller to pass s_scale
#         directly; if < 0 (default) it is recomputed internally as before, so all
#         existing call-sites that omit it continue to work unchanged.
#     A new private helper _kelly_fraction() computes the Half-Kelly multiplier
#     from signal_score, s_scale, and volatility and returns a float in [0, 1].
#     The sizing block (step 4-5) branches on self.limits.enable_kelly_sizing:
#       False (default) → identical to existing fixed-fractional logic.
#       True → Half-Kelly: risk_pct is replaced by kelly_fraction * max_risk_per_trade_pct,
#              then clamped to [min_risk_per_trade_pct, max_risk_per_trade_pct] so
#              Kelly can never exceed the existing hard caps.
#     No existing field, variable name, or method signature was renamed.

from dataclasses import dataclass, field
from typing import Optional, Dict

from .sentiment import SentimentResult
from config.config import RiskLimits, SentimentConfig, InstrumentMeta


@dataclass
class EquitySnapshot:
    equity: float
    cash: float
    portfolio_value: float
    day_trading_buying_power: float
    start_of_day_equity: float
    high_watermark_equity: float
    realized_pl_today: float
    unrealized_pl: float
    gross_exposure: float  # sum |position_notional|
    daily_loss_pct: float
    drawdown_pct: float


@dataclass
class PositionInfo:
    symbol: str
    qty: float
    market_price: float
    side: str  # long/short
    notional: float
    # Sentiment compound score recorded at entry time (rawcompound from SentimentResult).
    # Defaults to 0.0 so existing callsites that build PositionInfo without this
    # field continue to work — main.py patches it in after entry is confirmed.
    opening_compound: float = 0.0


@dataclass
class ProposedTrade:
    symbol: str
    side: str
    qty: float
    entry_price: float
    stop_price: float
    take_profit_price: float
    risk_amount: float
    risk_pct_of_equity: float
    sentiment_score: float
    sentiment_scale: float
    signal_score: float = 0.0
    rationale: Optional[str] = None
    rejected_reason: Optional[str] = None


class RiskEngine:
    def __init__(
        self,
        risk_limits: RiskLimits,
        sentiment_cfg: SentimentConfig,
        instrument_meta: Dict[str, InstrumentMeta],
    ) -> None:
        self.limits = risk_limits
        self.sentiment_cfg = sentiment_cfg
        self.instrument_meta = instrument_meta

    def sentiment_scale(self, s: float) -> float:
        if s < self.sentiment_cfg.no_trade_negative_threshold:
            return 0.0
        if abs(s) <= self.sentiment_cfg.neutral_band:
            return 1.0
        span = self.sentiment_cfg.max_scale - self.sentiment_cfg.min_scale
        scaled = self.sentiment_cfg.min_scale + (s + 1) / 2 * span
        return max(self.sentiment_cfg.min_scale, min(self.sentiment_cfg.max_scale, scaled))

    # ── Feature 3: Half-Kelly helper ──────────────────────────────────────────

    def _kelly_fraction(
        self,
        signal_score: float,
        s_scale: float,
        volatility: float,
    ) -> float:
        """
        Compute a Half-Kelly multiplier in [0.0, 1.0].

        Kelly formula: f* = (p*b - q) / b   where
          b  = reward/risk ratio proxy derived from |signal_score| and s_scale
          p  = estimated win probability  (mapped from |signal_score| and s_scale)
          q  = 1 - p

        Both b and p are estimated from the composite signal rather than from
        historical trade outcomes (which we do not track here).  The estimates
        are intentionally conservative:

          conviction = |signal_score| * s_scale  ∈ [0, 1.3]
            — combines technical edge (|signal_score|) with sentiment
              confirmation (s_scale ≥ 1 is favourable, < 1 is cautious).

          p = 0.5 + 0.15 * min(conviction, 1.0)
            — neutral market → p = 0.5; max conviction → p = 0.65.
            — Keeps us inside the "realistic" win-rate band for short-term equity.

          b = max(1.0, 1.5 * min(conviction, 1.0) + 1.0)
            — Minimum reward/risk of 1.0; scales with conviction up to ~2.5.

          vol_penalty = 1.0 / (1.0 + vol_factor)
            — Higher volatility shrinks the Kelly fraction; acts as a
              volatility-adjusted position sizing damper.
            — vol_factor normalises raw per-bar std-dev (typically 0.001–0.02)
              to a meaningful scale.

        The raw Full Kelly is then halved (Half-Kelly) and clamped to [0, 1].

        This approach is intentionally conservative and opinionated.
        Reference: https://pyquantnews.com/the-pyquant-newsletter/use-kelly-criterion-optimal-position-sizing
        """
        conviction = abs(signal_score) * s_scale                   # [0, ~1.3]
        conviction = min(conviction, 1.0)                          # cap at 1

        p = 0.5 + 0.15 * conviction                                # [0.50, 0.65]
        q = 1.0 - p
        b = 1.0 + 1.5 * conviction                                 # [1.0, 2.5]

        if b <= 0:
            return 0.0

        full_kelly = (p * b - q) / b                               # Kelly criterion
        half_kelly = full_kelly * 0.5                              # Half-Kelly

        # Volatility penalty: normalise raw per-bar std-dev.
        # A typical per-bar std-dev of ~0.005 (0.5%) maps to vol_factor ≈ 1.0.
        vol_factor = volatility / 0.005 if volatility > 0 else 0.0
        vol_penalty = 1.0 / (1.0 + vol_factor)

        kelly = half_kelly * vol_penalty

        return max(0.0, min(1.0, kelly))

    # ── Main pre-trade check ──────────────────────────────────────────────────

    def pre_trade_checks(
        self,
        snapshot: EquitySnapshot,
        positions: Dict[str, "PositionInfo"],
        symbol: str,
        side: str,
        entry_price: float,
        stop_price: float,
        take_profit_price: float,
        sentiment: SentimentResult,
        signal_score: float = 0.0,
        rationale: Optional[str] = None,
        volatility: float = 0.0,
        sentiment_scale_override: float = -1.0,
    ) -> ProposedTrade:
        """
        Run all pre-trade checks and compute position size.

        New keyword args (Feature 3, both have safe defaults so existing callers
        are unaffected):
          volatility: per-symbol return std-dev from SignalEngine._compute_volatility().
                      Used only when enable_kelly_sizing is True.
          sentiment_scale_override: if >= 0 the value is used directly as s_scale
                      (avoids re-computing when the caller already has it).
                      Default -1.0 triggers the existing internal computation.
        """
        # 0) Instrument whitelist
        if symbol not in self.instrument_meta:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=0.0,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Instrument not whitelisted",
            )

        # 1) hard block for unstable / utterly undesirable sentiment (-2)
        if getattr(sentiment, "raw_discrete", 0) == -2:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=0.0,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Sentiment -2 (unstable / do not trade)",
            )

        meta = self.instrument_meta[symbol]

        # 2) Sentiment-based sizing scale
        if sentiment_scale_override >= 0.0:
            s_scale = sentiment_scale_override
        else:
            s_scale = self.sentiment_scale(sentiment.score)

        if s_scale == 0.0:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=0.0,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Sentiment too negative for new trade",
            )

        # 3) Validate stop distance
        stop_distance = abs(entry_price - stop_price)
        if stop_distance <= 0:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Invalid stop distance",
            )

        # 4) Risk per trade — fixed-fractional OR Half-Kelly
        if self.limits.enable_kelly_sizing:
            # Feature 3: Half-Kelly fraction scales the max allowable risk %.
            # The result is still clamped to [min, max] so Kelly can never
            # override the hard risk caps set by the operator.
            kelly_f = self._kelly_fraction(signal_score, s_scale, volatility)
            raw_risk_pct = kelly_f * self.limits.max_risk_per_trade_pct
        else:
            # Original fixed-fractional path (unchanged)
            raw_risk_pct = self.limits.max_risk_per_trade_pct * s_scale

        risk_pct = min(
            self.limits.max_risk_per_trade_pct,
            max(self.limits.min_risk_per_trade_pct, raw_risk_pct),
        )
        risk_amount = snapshot.equity * risk_pct

        # 5) Size by risk and force whole-lot qty
        qty = risk_amount / stop_distance
        qty = int(qty / meta.lot_size) * meta.lot_size

        if qty <= 0:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=0.0,
                risk_pct_of_equity=0.0,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Calculated quantity is zero",
            )

        # 6) Broker-aware cap: fraction of equity per trade
        max_notional_broker = 0.4 * snapshot.equity
        projected_notional = qty * entry_price
        if projected_notional > max_notional_broker:
            max_qty_broker = int(max_notional_broker / entry_price / meta.lot_size) * meta.lot_size
            if max_qty_broker <= 0:
                return ProposedTrade(
                    symbol=symbol,
                    side=side,
                    qty=0.0,
                    entry_price=entry_price,
                    stop_price=stop_price,
                    take_profit_price=take_profit_price,
                    risk_amount=risk_amount,
                    risk_pct_of_equity=risk_pct,
                    sentiment_score=sentiment.score,
                    sentiment_scale=s_scale,
                    signal_score=signal_score,
                    rationale=rationale,
                    rejected_reason="Broker buying power cap per trade",
                )
            qty = max_qty_broker
            projected_notional = qty * entry_price

        # 7) Gross exposure / loss / drawdown / position-count rules
        projected_gross = snapshot.gross_exposure + abs(projected_notional)
        if projected_gross > snapshot.equity * self.limits.gross_exposure_cap_pct:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=risk_amount,
                risk_pct_of_equity=risk_pct,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Gross exposure cap breached",
            )

        if snapshot.daily_loss_pct <= -self.limits.daily_loss_limit_pct:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=risk_amount,
                risk_pct_of_equity=risk_pct,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Daily loss limit breached",
            )

        if snapshot.drawdown_pct <= -self.limits.max_drawdown_pct:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=risk_amount,
                risk_pct_of_equity=risk_pct,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Max drawdown limit breached",
            )

        if len(positions) >= self.limits.max_open_positions and symbol not in positions:
            return ProposedTrade(
                symbol=symbol,
                side=side,
                qty=0.0,
                entry_price=entry_price,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                risk_amount=risk_amount,
                risk_pct_of_equity=risk_pct,
                sentiment_score=sentiment.score,
                sentiment_scale=s_scale,
                signal_score=signal_score,
                rationale=rationale,
                rejected_reason="Max open positions exceeded",
            )

        return ProposedTrade(
            symbol=symbol,
            side=side,
            qty=qty,
            entry_price=entry_price,
            stop_price=stop_price,
            take_profit_price=take_profit_price,
            risk_amount=risk_amount,
            risk_pct_of_equity=risk_pct,
            sentiment_score=sentiment.score,
            sentiment_scale=s_scale,
            signal_score=signal_score,
            rationale=rationale,
            rejected_reason=None,
        )

-----------

-----------
core\sentiment.py
# CHANGES:
#   - Added force_rescore(symbol, newsitems) method.
#     This bypasses the TTL cache and chaos cooldown to always call the AI for
#     open-position sentiment-exit checks. It still writes the result back to the
#     cache so subsequent normal scoring benefits from it.
#     The existing scorenewsitems(), get_cached_sentiment(), _neutral(),
#     _map_discrete_to_score(), _get_last_known(), _set_last_known() methods are
#     completely untouched. No field renames.

from __future__ import annotations

import os
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

from ai_client import NewsReasoner


@dataclass
class SentimentResult:
    """
    score: continuous sentiment score in [-1, 1] for risk sizing.
           -1 strongly negative, +1 strongly positive.
           For discrete -2 (utterly undesirable / unstable), score is fixed at -1
           and should trigger no-trade / forced exit logic at the risk engine level.
    raw_discrete: the raw discrete value from the model in {-2, -1, 0, 1}
    rawcompound: legacy field; kept for compatibility, here = score
    ndocuments: number of news items used
    explanation: optional short explanation
    confidence: model-reported confidence in [0, 1]
    """
    score: float
    raw_discrete: int
    rawcompound: float
    ndocuments: int
    explanation: Optional[str] = None
    confidence: float = 0.0


class SentimentModule:
    """
    Sentiment engine backed by Perplexity Sonar via NewsReasoner.

    Implements cost controls:
      (1) TTL-based per-symbol cache to reduce AI calls.
      (2) If no *new* news arrives for a symbol, reuse last-known sentiment (no AI call).
      (6) If last-known raw_discrete == -2, apply a cooldown window during which we do not
          call the AI again for that symbol (even if new news arrives).
    """

    def __init__(self) -> None:
        self.reasoner = NewsReasoner()

        ttl_min = int(os.getenv("SENTIMENT_CACHE_TTL_MIN", "30"))
        ttl_min = max(1, ttl_min)
        self.cache_ttl = timedelta(minutes=ttl_min)

        chaos_cd_min = int(os.getenv("SENTIMENT_CHAOS_COOLDOWN_MIN", "120"))
        chaos_cd_min = max(0, chaos_cd_min)
        self.chaos_cooldown = timedelta(minutes=chaos_cd_min)

        # Cache is the single source of truth for last-known sentiment.
        # symbol -> (SentimentResult, timestamp_utc)
        self._cache: Dict[str, Tuple[SentimentResult, datetime]] = {}

    def _neutral(self, reason: str, ndocs: int = 0) -> SentimentResult:
        return SentimentResult(
            score=0.0,
            raw_discrete=0,
            rawcompound=0.0,
            ndocuments=ndocs,
            explanation=reason,
            confidence=0.0,
        )

    def _map_discrete_to_score(self, sdisc: int, confidence: float) -> float:
        """
        Map discrete sentiment {-2, -1, 0, 1} plus confidence into a continuous score in [-1, 1].
        """
        confidence = max(0.0, min(1.0, confidence))

        if sdisc == -2:
            # Hard floor at -1 to signal "utterly undesirable / unstable".
            return -1.0

        if sdisc == -1:
            base = -1.0
        elif sdisc == 0:
            base = 0.0
        elif sdisc == 1:
            base = 1.0
        else:
            base = 0.0

        return max(-1.0, min(1.0, base * confidence))

    def get_cached_sentiment(self, symbol: str) -> Optional[SentimentResult]:
        """
        TTL cache getter.
        Returns a cached sentiment only if it is within the TTL window.
        """
        now = datetime.utcnow()
        cached = self._cache.get(symbol)
        if not cached:
            return None
        result, ts = cached
        if now - ts <= self.cache_ttl:
            return result
        return None

    def _get_last_known(self, symbol: str) -> Optional[Tuple[SentimentResult, datetime]]:
        return self._cache.get(symbol)

    def _set_last_known(self, symbol: str, result: SentimentResult) -> None:
        self._cache[symbol] = (result, datetime.utcnow())

    def _call_ai(self, symbol: str, newsitems: List[dict]) -> SentimentResult:
        """
        Internal: call the AI, parse the result, update the cache, and return a
        SentimentResult. Used by both scorenewsitems() and force_rescore().
        """
        res = self.reasoner.scorenews(symbol, newsitems)

        try:
            sdisc = int(res.get("sentiment", 0))
        except (TypeError, ValueError):
            sdisc = 0
        if sdisc not in (-2, -1, 0, 1):
            sdisc = 0

        try:
            confidence = float(res.get("confidence", 0.0))
        except (TypeError, ValueError):
            confidence = 0.0
        confidence = max(0.0, min(1.0, confidence))

        explanation = res.get("explanation", "") or ""
        score = self._map_discrete_to_score(sdisc, confidence)

        result = SentimentResult(
            score=score,
            raw_discrete=sdisc,
            rawcompound=score,
            ndocuments=len(newsitems),
            explanation=explanation,
            confidence=confidence,
        )
        self._set_last_known(symbol, result)
        return result

    def scorenewsitems(self, symbol: str, newsitems: List[dict]) -> SentimentResult:
        """
        newsitems: list of dicts (typically *new since last check* from Alpaca news API),
                  each with at least 'headline' and/or 'summary'.

        Cost controls:
          - If there are no new news items and we have a last-known sentiment, reuse it. (2)
          - If cached sentiment is still fresh (TTL), reuse it. (1)
          - If last-known sentiment is -2 and still within cooldown, reuse it. (6)
        """
        now = datetime.utcnow()
        last_known = self._get_last_known(symbol)

        # (6) Chaos cooldown: if we recently deemed the symbol "unstable / -2", don't rescore.
        if last_known:
            last_res, last_ts = last_known
            if last_res.raw_discrete == -2 and (now - last_ts) <= self.chaos_cooldown:
                return last_res

        # (2) No new news -> do not call AI; just reuse last-known sentiment if available.
        if not newsitems:
            if last_known:
                return last_known[0]
            return self._neutral("No recent news (no prior sentiment cached).", ndocs=0)

        # (1) TTL cache: if within TTL, reuse cached sentiment even if new news exists.
        # Rationale: avoids frequent rescores when headlines trickle in; TTL bounds staleness.
        cached_fresh = self.get_cached_sentiment(symbol)
        if cached_fresh is not None:
            return cached_fresh

        return self._call_ai(symbol, newsitems)

    def force_rescore(self, symbol: str, newsitems: List[dict]) -> SentimentResult:
        """
        Unconditional AI rescore — bypasses TTL cache and chaos cooldown.

        Use this exclusively for open-position sentiment-exit checks, where stale
        cached data would cause the exit logic to silently produce delta = 0 and
        never fire.

        If newsitems is empty the AI cannot reason about new information; in that
        case we fall back to the last-known cached result (if any) or neutral.
        We do NOT want to exit a position solely because news is thin — the caller
        must decide what to do with a low-confidence neutral result.
        """
        if not newsitems:
            last_known = self._get_last_known(symbol)
            if last_known:
                return last_known[0]
            return self._neutral("No recent news for forced rescore.", ndocs=0)

        return self._call_ai(symbol, newsitems)

-----------

-----------
core\signals.py
# CHANGES:
#   - Feature 4 — Proper Wilder's RSI:
#     _compute_rsi() replaces the incorrect simple-average implementation with
#     the canonical Wilder's EMA-smoothed RSI:
#       • Seed: compute a plain SMA of gains and losses over the first `period` deltas.
#       • Subsequent bars: apply Wilder's smoothing formula
#           avg_gain = (prev_avg_gain * (period - 1) + current_gain) / period
#       • Returns 50.0 when insufficient bars are available (unchanged guard).
#     The method name _compute_rsi and its signature (bars, period=14) are
#     completely unchanged.
#   - Feature 3 wiring: generate_signal_for_symbol() now passes `volatility` and
#     `sentiment_scale_override` into risk_engine.pre_trade_checks() via
#     portfolio_builder → this file does NOT call pre_trade_checks directly, so
#     the wiring is done in portfolio_builder.py (see that file).
#     Here we ensure `volatility` is accessible on the Signal dataclass so
#     PortfolioBuilder can forward it.  A new field `volatility: float = 0.0` is
#     added to Signal (additive, default 0.0 — no existing consumer breaks).
#   - Import: removed `log_sentiment_for_symbol, log_signal_score` (both
#     deprecated shims). Replaced with a direct import of `log_instrument_report`
#     from monitoring.monitor.
#   - generate_signal_for_symbol(): replaced the call to log_signal_score() with
#     a single log_instrument_report() call placed AFTER the sentiment fetch.
#     The separate log_sentiment_for_symbol() call that followed has been removed
#     because log_instrument_report already renders the full sentiment block.
#   - The skip-branch now also calls log_instrument_report() with the neutral
#     sentinel SentimentResult so every symbol gets a report regardless of trade
#     decision.

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

import math

from adapters.alpaca_adapter import AlpacaAdapter
from config.config import ENV_MODE, TechnicalSignalConfig
from monitoring.monitor import log_instrument_report

from .sentiment import SentimentModule, SentimentResult


@dataclass
class Signal:
    symbol: str
    side: str  # "buy", "sell", or "skip"
    rationale: str
    sentiment_result: SentimentResult
    stop_price: float
    take_profit_price: float
    signal_score: float
    momentum_score: float
    mean_reversion_score: float
    price_action_score: float
    # Feature 3: expose per-symbol volatility so PortfolioBuilder can forward
    # it to RiskEngine.pre_trade_checks() for Half-Kelly sizing.
    volatility: float = 0.0


class SignalEngine:
    """
    Composite technical signal engine:
      - Momentum/trend
      - Mean reversion (RSI / MA distance proxy)
      - Price action structure

    AI cost controls implemented here:
      (3) Compute technical signal first; if side == "skip", do not fetch news or call AI.
    Suggestion (2) is enforced in SentimentModule.scorenewsitems via reuse when no new news arrives.
    """

    def __init__(
        self,
        adapter: AlpacaAdapter,
        sentiment: SentimentModule,
        technicalcfg: TechnicalSignalConfig,
    ):
        self.adapter = adapter
        self.sentiment = sentiment
        self.technicalcfg = technicalcfg

    def _compute_simple_momentum_raw(self, bars: List) -> float:
        """
        Simple momentum: (Current Close - Close N bars ago) / Close N bars ago
        """
        if not bars or len(bars) < 10:
            return 0.0

        # fallback if not enough bars for full lookback, just use what we have
        lookback = min(len(bars) - 1, 10)
        current = bars[-1].c
        past = bars[-1 - lookback].c

        if past == 0:
            return 0.0
        return (current - past) / past

    def _compute_trend_signal_raw(self, bars: List) -> float:
        """
        Simple trend proxy: is price above SMA(20)?
        Returns +1 if > SMA, -1 if < SMA, 0 otherwise.
        """
        if len(bars) < 20:
            return 0.0

        closes = [b.c for b in bars]
        # last 20 bars
        window = closes[-20:]
        sma = sum(window) / len(window)
        current = closes[-1]

        if current > sma:
            return 1.0
        elif current < sma:
            return -1.0
        return 0.0

    def _compute_volatility(self, bars: List) -> float:
        """
        ATR-like proxy or simple std dev of last N closes.
        Let's use a percentage volatility proxy: Stdev(returns) * sqrt(bars)
        """
        if len(bars) < 5:
            return 0.01  # fallback

        closes = [b.c for b in bars]
        returns = []
        for i in range(1, len(closes)):
            r = (closes[i] - closes[i-1]) / closes[i-1]
            returns.append(r)

        if not returns:
            return 0.01

        mean_ret = sum(returns) / len(returns)
        sq_diffs = [(r - mean_ret)**2 for r in returns]
        variance = sum(sq_diffs) / len(returns)
        std_dev = math.sqrt(variance)

        # Annualized-ish or per-bar? Just use per-bar std dev as vol proxy
        return std_dev

    def _compute_rsi(self, bars: List, period: int = 14) -> float:
        """
        Wilder's EMA-smoothed RSI.

        Algorithm:
          1. Require at least period+1 closes (unchanged guard — returns 50.0
             when insufficient data).
          2. Compute per-bar price changes for ALL available bars.
          3. Seed avg_gain / avg_loss with a plain SMA of the FIRST `period`
             deltas — this is the standard Wilder initialisation.
          4. Roll Wilder's EMA forward over all remaining deltas:
               avg_gain = (avg_gain * (period - 1) + gain) / period
               avg_loss = (avg_loss * (period - 1) + loss) / period
          5. Compute RS and RSI from the final smoothed averages.

        This produces the same values as TradingView / most professional
        charting libraries, unlike the previous simple-average approach which
        used all gains/losses pooled indiscriminately and returned a biased
        result.
        """
        if len(bars) < period + 1:
            return 50.0

        closes = [b.c for b in bars]
        deltas = [closes[i] - closes[i - 1] for i in range(1, len(closes))]

        # Step 3: seed with plain SMA of first `period` deltas
        seed_gains = [max(d, 0.0) for d in deltas[:period]]
        seed_losses = [abs(min(d, 0.0)) for d in deltas[:period]]
        avg_gain = sum(seed_gains) / period
        avg_loss = sum(seed_losses) / period

        # Step 4: Wilder's EMA smoothing over all remaining deltas
        for delta in deltas[period:]:
            gain = max(delta, 0.0)
            loss = abs(min(delta, 0.0))
            avg_gain = (avg_gain * (period - 1) + gain) / period
            avg_loss = (avg_loss * (period - 1) + loss) / period

        # Step 5: RSI
        if avg_loss == 0.0:
            return 100.0

        rs = avg_gain / avg_loss
        return 100.0 - (100.0 / (1.0 + rs))

    def _normalize_momentum_trend(self, mom_raw: float, trend_raw: float) -> float:
        # Scale momentum: if mom is 1%, that's huge in 5min bars.
        # standardizing roughly: mom / 0.005 -> clamped
        mom_score = max(-1.0, min(1.0, mom_raw / self.technicalcfg.momentum_norm_scale))

        # Combine with trend (-1 or 1)
        # 70% momentum value, 30% trend direction
        combined = 0.7 * mom_score + 0.3 * trend_raw
        return combined

    def _normalize_mean_reversion(self, current_price: float, bars: List, rsi: float) -> float:
        """
        Mean reversion score:
        High RSI (>70) -> Negative score (expect pullback)
        Low RSI (<30) -> Positive score (expect bounce)

        Also distance from MA: if price >> MA, revert down (-).
        """
        # RSI component
        rsi_score = 0.0
        if rsi > self.technicalcfg.rsi_overbought:
            # e.g. 75 -> -0.5
            rsi_score = -1.0 * (rsi - 70) / 30.0
        elif rsi < self.technicalcfg.rsi_oversold:
            # e.g. 25 -> +0.5
            rsi_score = 1.0 * (30 - rsi) / 30.0

        # MA distance component
        if len(bars) < 20:
            ma_score = 0.0
        else:
            closes = [b.c for b in bars[-20:]]
            sma = sum(closes) / len(closes)
            # (price - sma) / sma
            dist = (current_price - sma) / sma
            # if dist is +1%, score is negative (revert)
            # scale: 0.05 (5%) -> full -1.0
            ma_score = -1.0 * (dist / self.technicalcfg.ma_distance_norm_scale)

        return max(-1.0, min(1.0, 0.5 * rsi_score + 0.5 * ma_score))

    def _compute_price_action_score(self, bars: List, current_price: float) -> float:
        """
        Simple breakout detection:
        If current price > highest of last N bars -> +1 (Breakout)
        If current price < lowest of last N bars -> -1 (Breakdown)
        """
        if len(bars) < self.technicalcfg.breakout_lookback_bars:
            return 0.0

        window = bars[-self.technicalcfg.breakout_lookback_bars:-1]  # exclude current
        highs = [b.h for b in window]
        lows = [b.l for b in window]

        recent_high = max(highs)
        recent_low = min(lows)

        if current_price > recent_high:
            return 1.0
        elif current_price < recent_low:
            return -1.0

        return 0.0

    def _combine_technical_scores(self, mom: float, mr: float, pa: float) -> float:
        # weights from config
        score = (
            self.technicalcfg.weight_momentum_trend * mom +
            self.technicalcfg.weight_mean_reversion * mr +
            self.technicalcfg.weight_price_action * pa
        )
        return max(-1.0, min(1.0, score))

    def _decide_side_and_bands(self, last_price: float, volatility: float, signal_score: float) -> Tuple[str, float, float]:
        long_th = float(self.technicalcfg.long_threshold)
        short_th = float(self.technicalcfg.short_threshold)

        side = "skip"
        if signal_score >= long_th:
            side = "buy"
        elif signal_score <= short_th:
            side = "sell"

        # Use price-based volatility proxy for bands.
        # If volatility is tiny, fall back to a minimal band.
        vol_px = max(0.0025 * last_price, volatility * last_price)

        stop_mult = float(self.technicalcfg.base_stop_vol_mult)
        tp_mult = float(self.technicalcfg.base_tp_vol_mult)

        tp_scale = 1.0
        # Scale TP slightly with conviction but clamp.
        min_tp_scale = float(self.technicalcfg.min_tp_scale_from_signal)
        max_tp_scale = float(self.technicalcfg.max_tp_scale_from_signal)
        tp_scale = max(min_tp_scale, min(max_tp_scale, 1.0 + 0.3 * abs(signal_score)))

        if side == "buy":
            stop = last_price - stop_mult * vol_px
            tp = last_price + tp_mult * vol_px * tp_scale
        elif side == "sell":
            stop = last_price + stop_mult * vol_px
            tp = last_price - tp_mult * vol_px * tp_scale
        else:
            # Still return bands, but they won't be used.
            stop = last_price
            tp = last_price

        return side, float(stop), float(tp)

    def _get_news_items(self, symbol: str) -> List[Dict]:
        """
        Fetch news from Alpaca adapter.
        Here we just ask for latest 10 items.
        """
        return self.adapter.get_news(symbol, limit=10)

    def generate_signal_for_symbol(self, symbol: str) -> Signal:
        last_trade = self.adapter.get_last_quote(symbol)
        bars = self.adapter.get_recent_bars(symbol, timeframe="5Min", lookback_bars=30)

        momentum_raw = self._compute_simple_momentum_raw(bars)
        trend_raw = self._compute_trend_signal_raw(bars)
        volatility = self._compute_volatility(bars)
        rsi = self._compute_rsi(bars)

        momentum_score = self._normalize_momentum_trend(momentum_raw, trend_raw)
        mean_reversion_score = self._normalize_mean_reversion(last_trade, bars, rsi)
        price_action_score = self._compute_price_action_score(bars, last_trade)

        signal_score = self._combine_technical_scores(
            momentum_score, mean_reversion_score, price_action_score
        )

        side, stop_price, take_profit_price = self._decide_side_and_bands(
            last_price=last_trade,
            volatility=volatility,
            signal_score=signal_score,
        )

        if side == "skip":
            rationale = (
                f"Composite technical signal_score={signal_score:.3f} "
                f"within neutral band; no trade."
            )
        elif side == "buy":
            rationale = (
                f"Long bias from composite technicals: signal_score={signal_score:.3f}, "
                f"momentum={momentum_score:.3f}, mean_reversion={mean_reversion_score:.3f}, "
                f"price_action={price_action_score:.3f}."
            )
        else:
            rationale = (
                f"Short bias from composite technicals: signal_score={signal_score:.3f}, "
                f"momentum={momentum_score:.3f}, mean_reversion={mean_reversion_score:.3f}, "
                f"price_action={price_action_score:.3f}."
            )

        # (Suggestion 3) If we have no technical setup, do NOT fetch news and do NOT call AI.
        if side == "skip":
            s_result = SentimentResult(
                score=0.0,
                raw_discrete=0,
                rawcompound=0.0,
                ndocuments=0,
                explanation="Skipped AI sentiment due to neutral technical signal.",
                confidence=0.0,
            )
            log_instrument_report(
                symbol=symbol,
                signal_score=signal_score,
                sentiment=s_result,
                momentum_score=momentum_score,
                mean_reversion_score=mean_reversion_score,
                price_action_score=price_action_score,
                env_mode=ENV_MODE,
            )
            return Signal(
                symbol=symbol,
                side=side,
                rationale=rationale,
                sentiment_result=s_result,
                stop_price=stop_price,
                take_profit_price=take_profit_price,
                signal_score=signal_score,
                momentum_score=momentum_score,
                mean_reversion_score=mean_reversion_score,
                price_action_score=price_action_score,
                volatility=volatility,
            )

        # News -> sentiment (cost controls 1, 2, 6 are enforced inside SentimentModule)
        news_items = self._get_news_items(symbol)
        s_result = self.sentiment.scorenewsitems(symbol, news_items)

        # Single unified report — includes live sentiment + all four technical scores.
        log_instrument_report(
            symbol=symbol,
            signal_score=signal_score,
            sentiment=s_result,
            momentum_score=momentum_score,
            mean_reversion_score=mean_reversion_score,
            price_action_score=price_action_score,
            env_mode=ENV_MODE,
        )

        return Signal(
            symbol=symbol,
            side=side,
            rationale=rationale,
            sentiment_result=s_result,
            stop_price=stop_price,
            take_profit_price=take_profit_price,
            signal_score=signal_score,
            momentum_score=momentum_score,
            mean_reversion_score=mean_reversion_score,
            price_action_score=price_action_score,
            volatility=volatility,
        )

-----------

-----------
execution\__init__.py

-----------

-----------
execution\order_executor.py
# execution/order_executor.py

import logging
import time
from typing import Optional

from alpaca_trade_api.rest import APIError
from adapters.alpaca_adapter import AlpacaAdapter
from core.risk_engine import ProposedTrade, PositionInfo
from core.sentiment import SentimentResult
from monitoring.monitor import (
    log_proposed_trade,
    log_sentiment_close_decision,
)
from config.config import ExecutionConfig

logger = logging.getLogger("tradebot")


class OrderExecutor:
    def __init__(
        self,
        adapter: AlpacaAdapter,
        env_mode: str,
        live_trading_enabled: bool,
        execution_cfg: ExecutionConfig,
    ) -> None:
        self.adapter = adapter
        self.env_mode = env_mode
        self.live_trading_enabled = live_trading_enabled
        self.execution_cfg = execution_cfg

    def _can_place_orders(self) -> bool:
        """
        Returns True if it is allowed to place real orders in the current environment.
        PAPER: always True.
        LIVE: only if live_trading_enabled is True.
        """
        if self.env_mode == "LIVE" and not self.live_trading_enabled:
            return False
        return True

    def _wait_for_position(self, symbol: str, timeout_sec: int) -> Optional[any]:
        """
        Wait briefly for the entry to fill so we can submit exit orders safely.
        """
        deadline = time.time() + max(0, int(timeout_sec))
        while time.time() < deadline:
            pos = self.adapter.get_position(symbol)
            if pos is not None:
                return pos
            time.sleep(1)
        return None

    def execute_proposed_trade(self, trade: ProposedTrade):
        # Log the proposed trade with environment mode
        log_proposed_trade(trade, self.env_mode)

        # Skip if rejected or zero qty
        if trade.rejected_reason is not None or trade.qty <= 0:
            return None

        # LIVE dry‑run protection
        if not self._can_place_orders():
            return None

        side = trade.side
        if side not in ("buy", "sell"):
            raise ValueError("side must be 'buy' or 'sell'")

        try:
            # 1) Entry: market order
            entry_order = self.adapter.submit_market_order(
                symbol=trade.symbol,
                qty=trade.qty,
                side=side,
                time_in_force=self.execution_cfg.entry_time_in_force,
            )
        except APIError as e:
            logger.error(f"Entry order placement failed for {trade.symbol}: {e}")
            return None

        # 2) If configured, attempt to place trailing stop + take profit AFTER fill
        if not self.execution_cfg.enable_trailing_stop and not self.execution_cfg.enable_take_profit:
            return entry_order

        pos = self._wait_for_position(trade.symbol, self.execution_cfg.post_entry_fill_timeout_sec)
        if pos is None:
            # Position not visible yet; next loop can protect it via monitoring logic if you add it later.
            return entry_order

        try:
            pos_qty = abs(float(getattr(pos, "qty", 0.0)))
        except Exception:
            pos_qty = abs(trade.qty)

        if pos_qty <= 0:
            return entry_order

        # Determine exit side opposite of entry
        exit_side = "sell" if side == "buy" else "buy"

        # Place Take Profit limit (optional)
        if self.execution_cfg.enable_take_profit:
            tp_price = round(float(trade.take_profit_price), 2)
            try:
                self.adapter.submit_take_profit_limit_order(
                    symbol=trade.symbol,
                    qty=pos_qty,
                    side=exit_side,
                    limit_price=tp_price,
                    time_in_force=self.execution_cfg.exit_time_in_force,
                )
            except APIError as e:
                logger.error(f"Take profit placement failed for {trade.symbol}: {e}")

        # Place Trailing Stop (5% trail by default)
        if self.execution_cfg.enable_trailing_stop:
            try:
                self.adapter.submit_trailing_stop_order(
                    symbol=trade.symbol,
                    qty=pos_qty,
                    side=exit_side,
                    trail_percent=float(self.execution_cfg.trailing_stop_percent),
                    time_in_force=self.execution_cfg.exit_time_in_force,
                )
            except APIError as e:
                logger.error(f"Trailing stop placement failed for {trade.symbol}: {e}")

        return entry_order

    def close_position_due_to_sentiment(
        self,
        position: PositionInfo,
        sentiment: SentimentResult,
        reason: str,
    ):
        """
        Close an existing position immediately because sentiment has flipped strongly against it.

        For a long position, we submit a sell market order of full qty.
        For a short position, we submit a buy market order of full qty.
        """
        log_sentiment_close_decision(
            symbol=position.symbol,
            side=position.side,
            qty=position.qty,
            sentiment_score=sentiment.score,
            confidence=sentiment.confidence,
            explanation=sentiment.explanation,
            env_mode=self.env_mode,
            reason=reason,
        )

        if not self._can_place_orders():
            return None

        if position.qty <= 0:
            return None

        if position.side == "long":
            side = "sell"
        elif position.side == "short":
            side = "buy"
        else:
            raise ValueError(f"Unexpected position side {position.side}")

        try:
            order = self.adapter.rest.submit_order(
                symbol=position.symbol,
                side=side,
                type="market",
                qty=abs(position.qty),
                time_in_force="day",
            )
            return order
        except APIError as e:
            logger.error(f"Close position failed for {position.symbol}: {e}")
            return None


-----------

-----------
execution\position_manager.py
from typing import Dict, Optional
from adapters.alpaca_adapter import AlpacaAdapter
from core.risk_engine import PositionInfo


class PositionManager:
    def __init__(self, adapter: AlpacaAdapter):
        self.adapter = adapter

    def get_positions(
        self,
        opening_compounds: Optional[Dict[str, float]] = None,
    ) -> Dict[str, PositionInfo]:
        """
        Returns the current open positions as a symbol-keyed dict.

        opening_compounds: optional mapping of symbol -> entry-time rawcompound.
        When supplied, each PositionInfo.opening_compound is populated from it
        so the sentiment-exit loop in main.py can compare entry vs. current
        compound even after the SentimentModule cache has been refreshed.
        """
        alpaca_positions = self.adapter.list_positions()
        compounds = opening_compounds or {}
        out: Dict[str, PositionInfo] = {}
        for p in alpaca_positions:
            qty = float(p.qty)
            price = float(p.current_price)
            notional = qty * price
            side = "long" if qty > 0 else "short"
            out[p.symbol] = PositionInfo(
                symbol=p.symbol,
                qty=qty,
                market_price=price,
                side=side,
                notional=notional,
                opening_compound=compounds.get(p.symbol, 0.0),
            )
        return out

-----------

-----------
main.py
# main.py
# CHANGES:
#   - _opening_compounds is now persisted to equity_state.json under key
#     "opening_compounds" (a dict of symbol -> float). This means the entry
#     sentiment baseline survives bot restarts — previously it was in-memory only
#     and reset to 0.0 on every restart, making all delta comparisons meaningless
#     after a cold start.
#   - _load_equity_state returns the full state dict as before; no signature change.
#   - _save_equity_state persists opening_compounds alongside the existing keys.
#   - main() loads _opening_compounds from state on startup via a new
#     _load_opening_compounds() helper so the hydration is explicit and isolated.
#   - Stale-entry purge in the main loop (symbols no longer in positions) already
#     existed; it now also writes state to disk after purging so removals persist.
#   - setup_logging now receives cfg.env_mode (banner shows environment label).
#   - log_portfolio_overview import moved to top-level imports (was a local import
#     inside the loop — no functional change, just cleaner).
#   - All variable names, loop structure, and other logic are completely untouched.

import logging
import json
from pathlib import Path
from datetime import datetime, date
import time
from typing import Dict

from config.config import load_config
from adapters.alpaca_adapter import AlpacaAdapter
from core.sentiment import SentimentModule
from core.signals import SignalEngine
from core.risk_engine import RiskEngine, EquitySnapshot, PositionInfo
from core.portfolio_builder import PortfolioBuilder
from execution.position_manager import PositionManager
from execution.order_executor import OrderExecutor
from monitoring.monitor import (
    setup_logging,
    log_equity_snapshot,
    log_environment_switch,
    log_kill_switch_state,
    log_sentiment_for_symbol,
    log_sentiment_position_check,
    log_portfolio_overview,
)
from monitoring.kill_switch import KillSwitch

logger = logging.getLogger("tradebot")

_STATE_PATH = Path("data/equity_state.json")


def _load_equity_state() -> Dict:
    if not _STATE_PATH.exists():
        return {}
    try:
        with _STATE_PATH.open("r") as f:
            return json.load(f)
    except Exception:
        return {}


def _save_equity_state(state: Dict) -> None:
    _STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
    with _STATE_PATH.open("w") as f:
        json.dump(state, f)


def _load_opening_compounds() -> Dict[str, float]:
    """
    Load the opening-compound registry from the persisted equity state.
    Returns an empty dict if the state file is missing or the key is absent.
    This ensures PositionInfo.opening_compound is populated correctly even
    after a bot restart, so the sentiment-exit delta comparison is always
    meaningful.
    """
    state = _load_equity_state()
    raw = state.get("opening_compounds", {})
    # Guard: only keep entries that are genuine floats.
    return {k: float(v) for k, v in raw.items() if isinstance(v, (int, float))}


def get_equity_snapshot_from_account(acct, positions: Dict[str, PositionInfo]) -> EquitySnapshot:
    equity = float(acct.equity)
    cash = float(acct.cash)
    portfolio_value = float(acct.portfolio_value)

    state = _load_equity_state()
    today_str = date.today().isoformat()

    last_day = state.get("last_trading_day")
    start_of_day_equity = float(state.get("start_of_day_equity", equity))
    high_watermark_equity = float(state.get("high_watermark_equity", equity))

    if last_day != today_str:
        start_of_day_equity = equity
        high_watermark_equity = equity
        state["last_trading_day"] = today_str

    if equity > high_watermark_equity:
        high_watermark_equity = equity

    if start_of_day_equity > 0:
        daily_loss_pct = (equity - start_of_day_equity) / start_of_day_equity
    else:
        daily_loss_pct = 0.0

    if high_watermark_equity > 0:
        drawdown_pct = (equity - high_watermark_equity) / high_watermark_equity
    else:
        drawdown_pct = 0.0

    state["start_of_day_equity"] = start_of_day_equity
    state["high_watermark_equity"] = high_watermark_equity
    # NOTE: opening_compounds is NOT touched here — it is managed exclusively
    # by main() to avoid accidental overwrites during snapshot refreshes.
    _save_equity_state(state)

    realized_pl_today = float(getattr(acct, "daytrade_pl", 0.0))
    unrealized_pl = float(getattr(acct, "unrealized_pl", 0.0))
    gross_exposure = sum(abs(p.notional) for p in positions.values())

    return EquitySnapshot(
        equity=equity,
        cash=cash,
        portfolio_value=portfolio_value,
        day_trading_buying_power=float(acct.daytrading_buying_power),
        start_of_day_equity=start_of_day_equity,
        high_watermark_equity=high_watermark_equity,
        realized_pl_today=realized_pl_today,
        unrealized_pl=unrealized_pl,
        gross_exposure=gross_exposure,
        daily_loss_pct=daily_loss_pct,
        drawdown_pct=drawdown_pct,
    )


def _persist_opening_compounds(opening_compounds: Dict[str, float]) -> None:
    """
    Write _opening_compounds into equity_state.json without disturbing any
    other keys (start_of_day_equity, high_watermark_equity, last_trading_day).
    """
    state = _load_equity_state()
    state["opening_compounds"] = opening_compounds
    _save_equity_state(state)


def _check_and_exit_on_sentiment(
    positions: Dict[str, PositionInfo],
    adapter: AlpacaAdapter,
    sentiment_module: SentimentModule,
    executor: OrderExecutor,
    cfg,
) -> None:
    """
    Iterate over ALL open positions first. For each one:

    1.  Fetch fresh news (force_rescore bypasses TTL cache and chaos cooldown).
    2.  Auto-close unconditionally if raw_discrete == -2 (chaos event); the
        chaos timer is written to the cache by _call_ai inside force_rescore.
    3.  Auto-close if abs(entry_compound - current_compound) >=
        exit_sentiment_delta_threshold AND confidence >= exit_confidence_min.
    4.  Emit a formatted per-instrument block via log_sentiment_position_check().

    opening_compound is sourced directly from PositionInfo.opening_compound,
    which main() patches in from _opening_compounds after each entry fill.
    This survives TTL expiry and bot restarts because _opening_compounds is now
    persisted to equity_state.json.
    """
    delta_threshold = cfg.sentiment.exit_sentiment_delta_threshold
    confidence_min  = cfg.sentiment.exit_confidence_min

    for symbol, position in list(positions.items()):
        try:
            entry_compound: float = position.opening_compound

            # Always fetch fresh news and force a real AI rescore.
            news_items = adapter.get_news(symbol, limit=10)
            current_sentiment = sentiment_module.force_rescore(symbol, news_items)

            current_compound: float = current_sentiment.score
            current_confidence: float = current_sentiment.confidence
            raw_discrete: int       = current_sentiment.raw_discrete

            # Compute directional delta (how much did sentiment move *against* the pos)
            if position.side == "long":
                delta = entry_compound - current_compound
            elif position.side == "short":
                delta = current_compound - entry_compound
            else:
                delta = 0.0

            # ── Exit decision ─────────────────────────────────────────────────
            closing      = False
            close_reason = ""

            if raw_discrete == -2:
                closing = True
                close_reason = (
                    f"raw_discrete=-2 (chaos / utterly unstable); "
                    f"chaos cooldown timer applied."
                )
            elif delta >= delta_threshold and current_confidence >= confidence_min:
                closing = True
                close_reason = (
                    f"Sentiment compound shifted Δ={delta:+.3f} "
                    f"(entry={entry_compound:+.3f} → current={current_compound:+.3f}) "
                    f"against {position.side} position; "
                    f"threshold={delta_threshold}, confidence={current_confidence:.2f}"
                )

            # ── Formatted per-instrument print block ─────────────────────────
            log_sentiment_position_check(
                position=position,
                entry_compound=entry_compound,
                current_sentiment=current_sentiment,
                delta=delta,
                delta_threshold=delta_threshold,
                confidence_min=confidence_min,
                closing=closing,
                close_reason=close_reason,
                env_mode=cfg.env_mode,
            )

            # ── Execute close if warranted ────────────────────────────────────
            if closing:
                executor.close_position_due_to_sentiment(
                    position=position,
                    sentiment=current_sentiment,
                    reason=close_reason,
                )

        except Exception as exc:
            logger.error(
                f"SentimentExit [{symbol}]: unexpected error during exit check: {exc}"
            )


def main():
    setup_logging()
    cfg = load_config()
    setup_logging(cfg.env_mode)
    log_environment_switch(cfg.env_mode, user="manual_start")

    adapter           = AlpacaAdapter(cfg.env_mode)
    sentiment         = SentimentModule()
    signal_engine     = SignalEngine(adapter, sentiment, cfg.technical)
    risk_engine       = RiskEngine(cfg.risk_limits, cfg.sentiment, cfg.instruments)
    pm                = PositionManager(adapter)
    executor          = OrderExecutor(adapter, cfg.env_mode, cfg.live_trading_enabled, cfg.execution)
    kill_switch       = KillSwitch(cfg.risk_limits)
    portfolio_builder = PortfolioBuilder(cfg, adapter, sentiment, signal_engine, risk_engine)

    # Registry: symbol -> sentiment.score recorded at entry time.
    # Persisted to equity_state.json so it survives bot restarts.
    _opening_compounds: Dict[str, float] = _load_opening_compounds()

    while True:
        acct      = adapter.get_account()
        positions = pm.get_positions(opening_compounds=_opening_compounds)
        snapshot  = get_equity_snapshot_from_account(acct, positions)
        market_open = adapter.get_market_open()
        log_equity_snapshot(snapshot, market_open=market_open)

        ks_state = kill_switch.check(snapshot)
        log_kill_switch_state(ks_state)
        if ks_state.halted:
            time.sleep(60)
            continue

        # ── STEP 1: SENTIMENT CHECK ON ALL OPEN POSITIONS ────────────────────
        if positions:
            _check_and_exit_on_sentiment(
                positions=positions,
                adapter=adapter,
                sentiment_module=sentiment,
                executor=executor,
                cfg=cfg,
            )
            # Refresh positions after potential closes.
            positions = pm.get_positions(opening_compounds=_opening_compounds)
            snapshot  = get_equity_snapshot_from_account(acct, positions)

            # Purge _opening_compounds for symbols no longer open, then persist.
            for sym in list(_opening_compounds.keys()):
                if sym not in positions:
                    del _opening_compounds[sym]
            _persist_opening_compounds(_opening_compounds)

        # ── STEP 2: EXPOSURE / POSITION-COUNT GUARD ──────────────────────────
        exposure_cap_notional = snapshot.equity * cfg.risk_limits.gross_exposure_cap_pct
        if (
            snapshot.gross_exposure >= exposure_cap_notional
            or len(positions) >= cfg.risk_limits.max_open_positions
        ):
            time.sleep(60)
            continue

        # ── STEP 3: BUILD AND EXECUTE NEW TRADES ─────────────────────────────
        open_orders     = adapter.list_orders(status="open")
        proposed_trades = portfolio_builder.build_portfolio(snapshot, positions, open_orders)

        log_portfolio_overview(proposed_trades, cfg.env_mode)

        for proposed in proposed_trades:
            order = executor.execute_proposed_trade(proposed)
            if order is not None and proposed.rejected_reason is None and proposed.qty > 0:
                # Record entry-time sentiment score as the opening compound baseline.
                _opening_compounds[proposed.symbol] = proposed.sentiment_score
                # Persist immediately so a crash/restart doesn't lose the entry record.
                _persist_opening_compounds(_opening_compounds)

        time.sleep(600)


if __name__ == "__main__":
    main()

-----------

-----------
monitoring\__init__.py

-----------

-----------
monitoring\kill_switch.py
from dataclasses import dataclass
from config.config import RiskLimits
from core.risk_engine import EquitySnapshot


@dataclass
class KillSwitchState:
    halted: bool
    reason: str


class KillSwitch:
    def __init__(self, limits: RiskLimits):
        self.limits = limits

    def check(self, snapshot: EquitySnapshot) -> KillSwitchState:
        if snapshot.daily_loss_pct <= -self.limits.daily_loss_limit_pct:
            return KillSwitchState(True, "Daily loss limit hit")
        if snapshot.drawdown_pct <= -self.limits.max_drawdown_pct:
            return KillSwitchState(True, "Max drawdown limit hit")
        return KillSwitchState(False, "")

-----------

-----------
monitoring\monitor.py
# CHANGES:
#   - log_sentiment_position_check(): fixed broken logger.info line at the
#     "docs=" row. On-disk line was:
#         logger.info(f"docs={current_sentiment.ndocuments}){RESET}")
#     which is missing {lc}, missing the "  " indent, and has a stray literal ")"
#     inside the string. Fixed to:
#         logger.info(f"{lc}  docs={current_sentiment.ndocuments}{RESET}")

import logging
import threading
from datetime import datetime
from typing import List, Optional

from core.risk_engine import EquitySnapshot, ProposedTrade, PositionInfo
from core.sentiment import SentimentResult
from monitoring.kill_switch import KillSwitchState

logger = logging.getLogger("tradebot")

# ── ANSI colour constants ─────────────────────────────────────────────────────
RESET        = "\033[0m"
LINEBLUE     = "\033[38;2;138;185;241m"
LINEYELLOW   = "\033[38;2;248;222;126m"
SEPCOLOR     = "\033[38;2;222;211;151m"
SIGNALRED    = "\033[38;2;220;53;69m"
SIGNALGREEN  = "\033[38;2;40;167;69m"
ITALICON     = "\033[3m"
ITALICOFF    = "\033[23m"
BRIGHTPURPLE = "\033[38;2;191;64;191m"
DEEPBLUE     = "\033[38;2;0;13;222m"

MARKETOPEN   = SIGNALGREEN
MARKETCLOSED = SIGNALRED

# ── Thread-safe line-colour toggle ────────────────────────────────────────────
_linetoggle      = 0
_linetoggle_lock = threading.Lock()


def next_line_color() -> str:
    global _linetoggle
    with _linetoggle_lock:
        _linetoggle = 0 if _linetoggle == 1 else 1
        return LINEBLUE if _linetoggle == 0 else LINEYELLOW


def separator_line() -> str:
    return f"{SEPCOLOR}" + "-" * 80 + f"{RESET}"


def _thick(w: int = 80) -> str:
    """Border glyphs only — no colour escapes; callers wrap in lc / RESET."""
    return "═" * w


def _thin(w: int = 80) -> str:
    """Border glyphs only — no colour escapes; callers wrap in lc / RESET."""
    return "─" * w


def sentiment_score_fragment(score: float, line_color: str) -> str:
    base = "sentiment="
    if score <= -0.5:
        return f"{base}{SIGNALRED}{score:.3f}{line_color}"
    if score >= 0.5:
        return f"{base}{SIGNALGREEN}{score:.3f}{line_color}"
    return f"{base}{score:.3f}"


def italicize_technical(text: str) -> str:
    if not text:
        return text
    terms = [
        "RSI", "MACD", "moving average", "moving averages", "EMA", "SMA",
        "Bollinger", "support", "resistance", "candles", "candle", "bar", "bars",
    ]
    out = text
    for term in terms:
        out = out.replace(term, f"{ITALICON}{term}{ITALICOFF}")
    return out


# ── Setup ─────────────────────────────────────────────────────────────────────

def setup_logging(env_mode: str = "") -> None:
    """
    Initialise root logger at INFO level (no-op if already initialised).
    Calls log_startup_banner() so callers need no separate banner call.
    Pass cfg.env_mode for a labelled banner; omit for an unlabelled one.
    """
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    log_startup_banner(env_mode)


def log_startup_banner(env_mode: str) -> None:
    logger.info(separator_line())
    logger.info(f"{DEEPBLUE}   TRADE BOT STARTING UP   {RESET}")
    if env_mode:
        logger.info(f"{DEEPBLUE}   Environment: {env_mode}{RESET}")
    logger.info(separator_line())


def log_environment_switch(env_mode: str, user: str) -> None:
    line_color = next_line_color()
    msg = f"{datetime.utcnow().isoformat()}Z ENV switch event: mode={env_mode}, user={user}"
    logger.warning(f"{line_color}{msg}{RESET}")


# ── Equity snapshot ───────────────────────────────────────────────────────────

def log_equity_snapshot(snapshot: EquitySnapshot, market_open: bool = False) -> None:
    line_color = next_line_color()
    market_badge = (
        f"{MARKETOPEN}[MARKET OPEN]{line_color}"
        if market_open
        else f"{MARKETCLOSED}[MARKET CLOSED]{line_color}"
    )
    msg = (
        f"{datetime.utcnow().isoformat()}Z EquitySnapshot: "
        f"{market_badge} "
        f"equity={snapshot.equity:.2f}, "
        f"cash={snapshot.cash:.2f}, "
        f"gross_exposure={snapshot.gross_exposure:.2f}, "
        f"daily_loss_pct={snapshot.daily_loss_pct:.3f}, "
        f"drawdown_pct={snapshot.drawdown_pct:.3f}"
    )
    logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


# ── Kill-switch ───────────────────────────────────────────────────────────────

def log_kill_switch_state(state: KillSwitchState) -> None:
    """
    BUG #3 fix: OK-branch was logger.debug() — invisible at INFO level.
    Now logger.info() so the heartbeat is visible every loop.
    """
    line_color = next_line_color()
    if state.halted:
        msg = f"{datetime.utcnow().isoformat()}Z KILL-SWITCH ACTIVATED: {state.reason}"
        logger.error(f"{line_color}{msg}{RESET}")
    else:
        msg = f"{datetime.utcnow().isoformat()}Z Kill-switch OK"
        logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


# ── Instrument Report ─────────────────────────────────────────────────────────

def log_instrument_report(
    symbol: str,
    signal_score: float,
    sentiment: SentimentResult,
    momentum_score: float,
    mean_reversion_score: float,
    price_action_score: float,
    env_mode: str,
) -> None:
    """
    Emit a structured Instrument Report block for a single symbol scan.

    ════════════════════════════════════════════════════════════════════════════
     [PAPER] Instrument Report  │  AAPL  |  value=+0.350
    Current Sentiment=+0.900
    reason=Earnings beat, raised guidance; analysts bullish short-term.
    ────────────────────────────────────────────────────────────────────────────
    Indicator Listing
    compound=+0.350   momentum=+0.412   mean_reversion=-0.050   price_action=+0.000
    ════════════════════════════════════════════════════════════════════════════
    """
    W  = 80
    lc = next_line_color()

    thick = _thick(W)
    thin  = _thin(W)

    # ── Header row ────────────────────────────────────────────────────────────
    env_badge   = f"[{env_mode}] " if env_mode else ""
    symbol_str  = f"{BRIGHTPURPLE}{symbol}{lc}"
    val_color   = SIGNALGREEN if signal_score >= 0 else SIGNALRED
    val_str     = f"{val_color}{signal_score:+.3f}{lc}"
    header_body = (
        f" {DEEPBLUE}{env_badge}Instrument Report{lc}  │  "
        f"{symbol_str}  |  value={val_str}"
    )

    # ── Current Sentiment row ─────────────────────────────────────────────────
    sc       = sentiment.score
    sc_color = SIGNALGREEN if sc >= 0.5 else (SIGNALRED if sc <= -0.5 else lc)
    sc_str   = f"{sc_color}{sc:+.3f}{lc}"
    sent_row = f"Current Sentiment={sc_str}"

    # ── Reason row ────────────────────────────────────────────────────────────
    expl_raw   = (sentiment.explanation or "").replace("\n", " ").strip()
    expl_fmt   = italicize_technical(expl_raw)
    reason_row = f"reason={expl_fmt}"

    # ── Indicator colours ─────────────────────────────────────────────────────
    # compound = signal_score (weighted technical composite).
    # This is signal_score, NOT sentiment.rawcompound (which is the AI score).
    cp       = signal_score
    cp_color = SIGNALGREEN if cp >= 0 else SIGNALRED
    cp_str   = f"{cp_color}{cp:+.3f}{lc}"

    mom_color = SIGNALGREEN if momentum_score >= 0 else SIGNALRED
    mom_str   = f"{mom_color}{momentum_score:+.3f}{lc}"

    mr_color  = SIGNALGREEN if mean_reversion_score >= 0 else SIGNALRED
    mr_str    = f"{mr_color}{mean_reversion_score:+.3f}{lc}"

    pa_color  = SIGNALGREEN if price_action_score >= 0 else SIGNALRED
    pa_str    = f"{pa_color}{price_action_score:+.3f}{lc}"

    # ── Indicator Listing — all four on one line ───────────────────────────────
    ind_row = (
        f"compound={cp_str}   "
        f"momentum={mom_str}   "
        f"mean_reversion={mr_str}   "
        f"price_action={pa_str}"
    )

    # ── Formula row — italicised factor breakdown ──────────────────────────────
    formula_row = (
        f"  Compound Score={cp_str}   "
        f"{ITALICON}momentum={mom_color}{momentum_score:+.3f}{lc}{ITALICOFF}   "
        f"{ITALICON}mean_reversion={mr_color}{mean_reversion_score:+.3f}{lc}{ITALICOFF}   "
        f"{ITALICON}price_action={pa_color}{price_action_score:+.3f}{lc}{ITALICOFF}"
    )

    logger.info(f"{lc}{thick}{RESET}")
    logger.info(f"{lc}{header_body}{RESET}")
    logger.info(f"{lc}{sent_row}{RESET}")
    logger.info(f"{lc}{reason_row}{RESET}")
    logger.info(f"{lc}{thin}{RESET}")
    logger.info(f"{lc}Indicator Listing{RESET}")
    logger.info(f"{lc}{ind_row}{RESET}")
    logger.info(f"{lc}{thin}{RESET}")
    logger.info(f"{lc}{formula_row}{RESET}")
    logger.info(f"{lc}{thick}{RESET}")


# ── Deprecated shims ──────────────────────────────────────────────────────────
# These exist only so any OTHER file that still imports them doesn't crash.
# core/signals.py no longer calls them. Do NOT add logger.warning() here —
# the warnings were the user-visible noise we're eliminating.

def log_sentiment_for_symbol(symbol: str, sentiment: SentimentResult, env_mode: str) -> None:
    """Deprecated shim — preserved for import compatibility only."""
    log_instrument_report(
        symbol=symbol,
        signal_score=0.0,
        sentiment=sentiment,
        momentum_score=0.0,
        mean_reversion_score=0.0,
        price_action_score=0.0,
        env_mode=env_mode,
    )


def log_signal_score(
    symbol: str,
    signal_score: float,
    momentum_score: float,
    mean_reversion_score: float,
    price_action_score: float,
    env_mode: str,
) -> None:
    """Deprecated shim — preserved for import compatibility only."""
    from core.sentiment import SentimentResult  # local import avoids circular at module load
    log_instrument_report(
        symbol=symbol,
        signal_score=signal_score,
        sentiment=SentimentResult(
            score=0.0, raw_discrete=0, rawcompound=0.0,
            ndocuments=0, explanation=None, confidence=0.0,
        ),
        momentum_score=momentum_score,
        mean_reversion_score=mean_reversion_score,
        price_action_score=price_action_score,
        env_mode=env_mode,
    )


# ── Proposed trade ────────────────────────────────────────────────────────────

def log_proposed_trade(trade: ProposedTrade, env_mode: str) -> None:
    """
    BUG #5 fix: unexpected trade.side now emits logger.warning() instead of
    silently producing an empty action_tag.
    """
    line_color     = next_line_color()
    sentiment_part = sentiment_score_fragment(trade.sentiment_score, line_color)
    action_tag     = ""
    if trade.rejected_reason is None and trade.qty > 0:
        if trade.side == "buy":
            action_tag = f" {SIGNALGREEN}BUY{line_color}"
        elif trade.side == "sell":
            action_tag = f" {SIGNALRED}SELL{line_color}"
        else:
            logger.warning(
                f"log_proposed_trade: unexpected side='{trade.side}' for "
                f"{trade.symbol} — expected 'buy' or 'sell'."
            )
    notional    = trade.qty * trade.entry_price
    symbol_part = f"{BRIGHTPURPLE}{trade.symbol}{line_color}"
    sig_part    = f"{BRIGHTPURPLE}{trade.signal_score:.3f}{line_color}"
    msg = (
        f"{datetime.utcnow().isoformat()}Z {env_mode} ProposedTrade "
        f"symbol={symbol_part} {trade.side} "
        f"qty={trade.qty:.4f} notional={notional:.2f} "
        f"entry={trade.entry_price:.4f} stop={trade.stop_price:.4f} tp={trade.take_profit_price:.4f} "
        f"risk_amt={trade.risk_amount:.2f} risk_pct={trade.risk_pct_of_equity:.4f} "
        f"{sentiment_part} scale={trade.sentiment_scale:.3f} "
        f"rejected={trade.rejected_reason} "
        f"{action_tag} "
        f"{sig_part}"
    )
    logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


# ── Sentiment close decision ──────────────────────────────────────────────────

def log_sentiment_close_decision(
    symbol: str,
    side: str,
    qty: float,
    sentiment_score: float,
    confidence: float,
    explanation: str,
    env_mode: str,
    reason: str,
) -> None:
    line_color  = next_line_color()
    score_frag  = sentiment_score_fragment(sentiment_score, line_color)
    expl_raw    = (explanation or "").replace("\n", " ").strip()
    expl_fmt    = italicize_technical(expl_raw)
    force_msg   = f"{SIGNALRED}FORCE-CLOSED DUE TO BAD SENTIMENT{line_color}"
    symbol_part = f"{BRIGHTPURPLE}{symbol}{line_color}"
    msg = (
        f"{datetime.utcnow().isoformat()}Z {env_mode} SentimentExit "
        f"symbol={symbol_part} side={side} qty={qty:.4f} "
        f"{score_frag} conf={confidence:.2f} "
        f"reason_for_exit={reason} "
        f"{force_msg} "
        f"{expl_fmt}"
    )
    logger.warning(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


# ── Portfolio overview ────────────────────────────────────────────────────────

def log_portfolio_overview(trades: List[ProposedTrade], env_mode: str) -> None:
    logger.info(separator_line())
    if not trades:
        header = f"{datetime.utcnow().isoformat()}Z {env_mode} PORTFOLIO OVERVIEW"
        logger.info(f"{DEEPBLUE}{header}{RESET}")
        logger.info(f"{DEEPBLUE}No new trades selected in this cycle.{RESET}")
        logger.info(separator_line())
        return

    line_color = next_line_color()
    header     = f"{datetime.utcnow().isoformat()}Z {env_mode} PORTFOLIO OVERVIEW"
    logger.info(f"{line_color}{header}{RESET}")
    for t in trades:
        notional    = t.qty * t.entry_price
        symbol_part = f"{BRIGHTPURPLE}{t.symbol}{line_color}"
        sig_str     = f"{BRIGHTPURPLE}{t.signal_score:.3f}{line_color}"
        msg = (
            f"  symbol={symbol_part} side={t.side} "
            f"qty={t.qty:.4f} notional={notional:.2f} "
            f"signal_score={sig_str} "
            f"rejected={t.rejected_reason}"
        )
        logger.info(f"{line_color}{msg}{RESET}")
    logger.info(separator_line())


# ── Sentiment position check ──────────────────────────────────────────────────

def log_sentiment_position_check(
    position: PositionInfo,
    entry_compound: float,
    current_sentiment: SentimentResult,
    delta: float,
    delta_threshold: float,
    confidence_min: float,
    closing: bool,
    close_reason: str,
    env_mode: str,
    stop_price: Optional[float] = None,
    take_profit_price: Optional[float] = None,
) -> None:
    """
    BUG #2 fix: triggered_tag and delta_color are also set when raw_discrete == -2
    (chaos exit), regardless of numeric delta, so the delta row is always visually
    consistent with the Verdict.

    BUG #4 fix: thick/thin carry no embedded RESET — callers wrap in lc/RESET.

    Current compound now uses current_sentiment.score (not .rawcompound).
    rawcompound == score always (set identically in _call_ai); using .score is
    semantically correct and consistent with how delta is computed in main.py.
    """
    W  = 80
    lc = next_line_color()

    thick = _thick(W)
    thin  = _thin(W)

    rd = current_sentiment.raw_discrete

    # ── Header row ────────────────────────────────────────────────────────────
    symbol_str   = f"{BRIGHTPURPLE}{position.symbol}{lc}"
    side_str     = (
        f"{SIGNALGREEN}{position.side.upper()}{lc}"
        if position.side == "long"
        else f"{SIGNALRED}{position.side.upper()}{lc}"
    )
    notional_val = abs(position.qty * position.market_price)
    header_body  = (
        f" {DEEPBLUE}SENTIMENT CHECK{lc}  │  "
        f"{symbol_str}  │  {side_str}  │  "
        f"qty={position.qty:.4f}  │  notional={notional_val:.2f}"
    )

    # ── Metadata row ──────────────────────────────────────────────────────────
    sc       = current_sentiment.score
    sc_color = SIGNALGREEN if sc >= 0.5 else (SIGNALRED if sc <= -0.5 else lc)
    sc_str   = f"{sc_color}{sc:+.3f}{lc}"

    ec_color = SIGNALGREEN if entry_compound >= 0 else SIGNALRED
    ec_str   = f"{ec_color}{entry_compound:+.3f}{lc}"

    sl_str = f"{stop_price:.2f}"        if stop_price        is not None else "N/A"
    tp_str = f"{take_profit_price:.2f}" if take_profit_price is not None else "N/A"

    meta_row = (
        f"Current Sentiment={sc_str}   |   "
        f"Opening Compound={ec_str}   |   "
        f"Stop Loss={sl_str}   |   "
        f"Take Profit={tp_str}"
    )

    # ── Entry compound ────────────────────────────────────────────────────────
    ec_str2 = f"{ec_color}{entry_compound:+.3f}{lc}"

    # ── Delta — BUG #2 fix: chaos exit also marks delta as triggered ──────────
    chaos_exit    = (rd == -2)
    delta_trigger = (delta >= delta_threshold)
    show_trigger  = delta_trigger or chaos_exit

    delta_color   = SIGNALRED if show_trigger else lc
    triggered_tag = (
        f"  {SIGNALRED}← TRIGGERED{lc}"
        if show_trigger
        else ""
    )
    delta_str = (
        f"{delta_color}{delta:+.3f}{lc}   "
        f"[threshold ≥ {delta_threshold:.3f}]{triggered_tag}"
    )

    # ── Explanation ───────────────────────────────────────────────────────────
    expl_raw = (current_sentiment.explanation or "").replace("\n", " ").strip()
    expl_fmt = italicize_technical(expl_raw)

    # ── Verdict ───────────────────────────────────────────────────────────────
    if closing:
        if chaos_exit:
            verdict_detail = (
                f"{SIGNALRED}⛔ CLOSING — raw_discrete = -2 (CHAOS / absolute exit){lc}"
            )
        else:
            verdict_detail = (
                f"{SIGNALRED}⛔ CLOSING — sentiment shift "
                f"Δ={delta:+.3f} ≥ threshold {delta_threshold:.3f}{lc}"
            )
    else:
        verdict_detail = f"{SIGNALGREEN}✔  HOLDING — no exit condition met{lc}"

    logger.info(f"{lc}{thick}{RESET}")
    logger.info(f"{lc}{header_body}{RESET}")
    logger.info(f"{lc}{thick}{RESET}")
    logger.info(f"{lc}{meta_row}{RESET}")
    logger.info(f"{lc}{thin}{RESET}")
    logger.info("")
    logger.info(f"{lc}  Entry compound   :  {ec_str2}{RESET}")
    logger.info("")
    logger.info("")
    logger.info(f"{lc}  Δ compound       :  {delta_str}{RESET}")
    logger.info("")
    logger.info(f"{lc}  Explanation      :  {expl_fmt}{RESET}")
    logger.info("")
    logger.info(f"{lc}{thin}{RESET}")
    logger.info("")
    logger.info(f"{lc}  Verdict          :  {verdict_detail}{RESET}")
    logger.info("")
    logger.info(f"{lc}{thick}{RESET}")

-----------

-----------
requirements.txt
alpaca-trade-api>=3.0.0
PyYAML>=6.0
vaderSentiment>=3.3.2
pytz>=2024.1

-----------

-----------
tests\__init__.py

-----------

-----------
todo.txt
2----------------------------------------------------------------------------------

Scrap upper and lower resistance with AI and use it in a viable capacity

3----------------------------------------------------------------------------------

test with different weights in composit value

4----------------------------------------------------------------------------------

tweak lot size based on weights

5----------------------------------------------------------------------------------

improve portfolio composition for better diversification

6----------------------------------------------------------------------------------

thats lowkey and highkey it


rank portfolio builder based on tech+sent score and distribute equity accordingly in viable positions

Fix the Monitor
-----------

